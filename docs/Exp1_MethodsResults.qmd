---
title: "Experiment 1: Method & Results"
format: docx
editor: visual
editor_options: 
  chunk_output_type: console
---

```{r options, include = FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  echo = FALSE,
  output = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  collapse = TRUE
)
```

```{r setup}
pacman::p_load(AntiSaccade, papaja, brms, dplyr, ggplot2, here, lavaan)
options(mc.cores = parallel::detectCores())

# plot settings
plot_dodge <- 1
jitter_width <- 1
point_alpha <- 0.1
```

# Methods

```{r data_prep}
data <- RawData_Exp5
nSub_total <- length(unique(data$ID))
data$CTI_num <- (data$CTI)/1000
data$CTI <- as.factor(data$CTI)
data$FixDur_num <- (data$FixDur - mean(unique(data$FixDur)))/1000

data$RTms <- data$RTms + 150

levels(data$Block) <- stringr::str_replace_all(levels(data$Block), "[:digit:]", "")

inhib_blocks <- c("Anti","Random")
bind_blocks <- c("Pro","Anti","Colour")
bottomup_blocks <- c("NoSaccade","Pro")
saccade_blocks <- c("Pro","Anti","Random","Central")

Block2Conds <- data.frame(
  Block = unique(data$Block)
)

data$inhibition <- ifelse(data$Block %in% inhib_blocks, 1, 0)
data$binding <- ifelse(data$Block %in% bind_blocks, 1, 0)
data$bottomup <- ifelse(data$Block %in% bottomup_blocks, 1, 0)
data$saccade <- ifelse(data$Block %in% saccade_blocks, 1, 0)

Block2Conds$inhibition <- ifelse(Block2Conds$Block %in% inhib_blocks,1, 0)
Block2Conds$binding <- ifelse(Block2Conds$Block %in% bind_blocks, 1, 0)
Block2Conds$bottomup <- ifelse(Block2Conds$Block %in% bottomup_blocks, 1, 0)
Block2Conds$saccade <- ifelse(Block2Conds$Block %in% saccade_blocks, 1, 0)

outlier_data <- data %>% 
  group_by(ID, Block, CTI) %>% 
  summarise(meanPC = mean(correct),
            nTrials = n(),
            .groups = "drop") %>% 
  group_by(Block,CTI) %>% 
  mutate(
    meanPC_logit = logit_scaled(meanPC - (0.5/nTrials)),
    zPC_logit = (meanPC_logit - mean(meanPC_logit))/sd(meanPC_logit))

outlier_IDs_guess <- unique(outlier_data$ID[which(outlier_data$meanPC <= qbinom(p = .95, size = outlier_data$nTrials, prob = 1/3)/outlier_data$nTrials)])
outlier_IDs_z <- unique(outlier_data$ID[which(outlier_data$zPC_logit <= qnorm(p = .01))])
outlier_IDs <- unique(c(outlier_IDs_guess,outlier_IDs_z))

data <- data %>% 
  filter(!ID %in% outlier_IDs)
nSub <- length(unique(data$ID))

# aggregate data for binomial models
agg_data <- data %>%
  dplyr::group_by(ID, Block, bottomup, saccade, inhibition, binding, FixDur, FixDur_num, CTI, CTI_num) %>%
  dplyr::summarise(
    correct = sum(correct),
    nTrials = dplyr::n(),
    .groups = "drop"
  )
```

## Participants

We recruited `r papaja::printnum(nSub_total)` participants via Prolific, `r nSub_total - nSub` participants were excluded for low performance, thus `r papaja::printnum(nSub)` participants were included in the data analyses. Participants were required to be 18 to 40 years old, speak English as their first language, and have an approval rate of at least 85% when participating in studies on Prolific.

The Manual anti-saccade task was programmed in lab.js (Henninger et al., 2020) and run via JATOS. The task was run locally on the participants machines, but we required that a laptop or desktop computer was used. Participation using a tablet or smartphone was not allowed. All tasks were run in a single session that lasted approximately 60 to 70 minutes.

## Design

This study was designed to isolate different processes contributing to performance in the manual anti saccade task. For this, we adapted previous versions of the manual anti-saccade (Kane et al., 2001) and increased the peripheral locations the target stimulus could appear in from 2 (left and right) to 4 (left, right, top, and bottom). This enabled us to introduce new experimental blocks in addition to the traditional Pro- and Anti-Saccade Blocks. Specifically, in this experiment, we included 3 additional blocks: a No-Saccade Block in which both the cue and the target appeared in the center of the screen, a Random Saccade Block in which the target could appear in any of the non-cued location, and a Central-Saccade Block in which the cue appeared in the center and the target could appear in any of the four peripheral locations. For an illustration of the manipulation implemented in these experimental blocks see Figure @fig-conditions.

![Illustration of the different experimental blocks. The top row exemplifies one of the locations the cue could appear in, and the bottom row highlights in which locations the target could appear in.](Conditions_Exp5.png){#fig-conditions fig-align="center"}

The idea underlying these different blocks is to systematically vary if participants need to inhibit automatic saccades towards the cue, and if the location the cue appears in is informative with respect to the target location. Thus, as already discussed in the introduction they require different processes that might be related to performance in the manual anti-saccade task. In detail, the No-Saccade block only requires to quickly discriminate between the target letters without any demands on controlling saccades and moving the eyes. The Pro-Saccade block adds the demands of performing a saccade to the cued locations. This could happen automatically or controlled. But it does not require to inhibit the automatic saccade. The Anti-Saccade block requires subjects to move their gaze to the opposite location of where the cue appeared. This requires inhibiting the automatic saccade elicited by the transient onset signal of the cue, and performing a controlled saccade to the opposite location. The Random saccade block require to inhibit the automatic saccade towards the cue, but does not allow for a controlled saccade towards the target location as it can not be inferred from the location the cue appeared in. Finally, the Central block neither requires to inhibit an automatic saccade, as the cue appears in the center, but also does not allow for a controlled saccade as the cue is not informative for the target location. But unlike in the No-Saccade condition the target does appear in one of the peripheral locations, thus only the transient onset signal of the target will draw attention towards the target location.

In addition, the blocks also differ in their requirements to perform saccades away from Fixation or from the Cue to detect the target letter. We included these factors, as they result in costs that occur because attention is partly guided by the transient onset signal of the cue. We aimed to separate these more exogenous processes of guiding attention, from the endogenous processes that are supposedly relying on attention control. An overview, of which processes were required in the different experimental blocks is shown in @tbl-Block2Proc

```{r Blocks2Procs}
#| label: tbl-Block2Proc
#| tab-cap: "Processes required by the different experimental blocks."
Table_Blocks2Procs <- Block2Conds %>% 
  mutate(PercSpeed = 1) %>% 
  select(Block, PercSpeed, inhibition, binding, saccade, bottomup)

Table_Blocks2Procs[,2:6] <- ifelse(Table_Blocks2Procs[,2:6] == 1, "yes","no")
Table_Blocks2Procs <- Table_Blocks2Procs[c(2,3,1,4,5),]
colnames(Table_Blocks2Procs) <- c("Block", "Perceptual Speed", "Inhibition", "Binding", "Saccade", "Bottom Up")
knitr::kable(Table_Blocks2Procs)
```

In addition, we varied the Cue-Traget Innterval in three levels: 50, 200, 400ms to evaluate if longer time to inhibit automatic saccades towards the cued-location when required and use the location of the cue to perform a controlled saccade when possible improves performance.[^1]

[^1]: We examined the different ranges of CTI durations in two pilot experiments (Experiments S1 & 2 in the online supplement) in three of the five experimental blocks (i.e. the Pro, Anti, and Random Saccade blocks). The results of these two experiments suggested that a range from 50 to 400 ms covers the CTI effects well.

## Trial Procedure

Each trial started with a fixation cross that was presented for a variable fixation duration from 200 to 1400 ms in steps of 400 ms. After the fixation cross the cue was presented either in one of the four peripheral locations or in the center (only for the No-Saccade Block). The cue, a "=" appeared for 100 ms, then offset for 50 ms, and appeared again for 100 ms. This flickering was done to increase the transient signal of the cue and maximize the elicitation of automatic saccades (Kane et al., 2001). The screen then was blank for a CTI of 50, 200, or 400ms. After that the target letter - either a "P", "B", or "R" - appeared for 100ms in one of the peripheral locations or in the center according to the specified rules for the current block. The target letter was then backward masked with an "H" appearing for 50ms immediately followed by an "8" remaining on screen until participants responded which letter they detected by pressing "P", "B", or "R" on the keyboard. For an illustration of the trial procedures see Figure @fig-trial)

![Illustration of the trial procedure.](Figure_SaccadeTask2.png){#fig-trial fig-align="center"}

For each trial, we recorded the response given as well as the response time as the time between onset of the target stimulus until the response. Each block started with instructions regarding the current condition that were followed by 10 practice trials where feedback was given. Then participants completed 144 experimental trials, so that each of the three target letters, appeared once in each of the four peripheral locations with each of the four fixation durations and three CTIs. The order of blocks was randomized across participants.

## Data Analysis

```{r CleanData}
n_full <- nrow(data)
data <- data %>% filter(RTms > 150, RTms < 5000)
n_filter <- nrow(data)

prop_filter <- (1 - n_filter/n_full) * 100
```

Prior to data analysis we removed trials with reaction times shorter than 150 ms and longer than 5000ms. This resulted in discarding `r papaja::printnum(prop_filter)`% of data.

We analyzed the number of correct responses with a Bayesian Generalized Linear Model assuming the number of correct responses follows a binomial distribution. We used a logit link function, thus estimating the linear model on the logit-scale. The model was estimated using the R package `brms`.

```{r model_family}
model_family <- brmsfamily("binomial", link = "logit")
```

To incorporate the theoretical assumptions outlined in the introduction, we specified that:

1.  conditions requiring the inhibition of the cued location (i.e. the Anti- and Random-Saccade block) would be lower in performance due to automatic activation from the cue $A_{cue}$. The lower this activation, the better a person is to avoid attention being captured by the cue. In theoretical terms differences between individuals in this activation from the cue represent pro-active control.
2.  automatic activation of the cue could be filtered out over time. This was implemented with an exponential decay function, reflecting that a certain proportion of cue activation gets filtered over time. The higher this filtering $f$, the better a person is to re-actively control attention and reduce activation from the cue over time.[^2]
3.  informative associations of cues to the target locations (in the Pro- and Anti-Saccade Block) could be used to improve performance over time. This binding activation $A_{binding}$ reflects a persons ability to use the association of the cued location to the target location to endogenously direct attention towards the cued location and improve the performance. We assumed that this process unfolds linearly with longer CTI duration.

[^2]: We chose to implement filtering this way, as two pilot experiments (Experiment S3 & 4 in the online supplement) have shown that participants only disengage attention from the cued location in the Random Saccade block, to redirect it towards the center of the screen, instead of entirely removing the cued location from the potential candidate positions the target could appear in. The latter could have resulted in a benefit for the Random Saccade Block over longer CTIs compared to the Central Saccade block, whereas the former only reduced the Cue Activation down to the baseline level that we measure in the Central Saccade Block.

Formally, this resulted in the following model:

$$
\begin{align}
\lambda_{j,k,l} &= b_{PercSpeed} + Inhib_j * b_{InhibPro} * e^{-b_{InhibReact}*CTI_k} + Binding_j + b_{Binding} * CTI_k \\
&= + Saccade_j * b_{Saccade} + BottomUp_j * b_{BottomUp} + GoalMain_j * b_{GoalMain} * PrepTime_l; \\
p_{j,k,l} &= \frac{1}{1 + e^{-\lambda_{j,k,l}}}
\end{align}
$$

For an illustration of these theoretically informed processes, see @fig-theory. Specifically, the dashed black line represents baseline performance if all of the above mentioned processes are not required. The differences at time 0 between the black and the red line represents the automatic activation of the cue, the smaller this difference the better the proactive inhibition of automatic saccades elicited by the onset of the cue. This cue activation declines exponentially towards the black line with time, reflective re-active inhibition. The green line represents the use of binding information over time that improves performance with longer CTI duration. As this model was implemented on the logit-scale, the increases in performance on the probability scale are non-linear for binding benefits as a result of the logit link function.

```{r Fig_TheoreticalModel}
#| label: fig-theory
#| fig-cap: "Illustration of the theoretically assumed processes and how they are affected by time."
#| fig-subcap:
#|   - "Logit Scale"
#|   - "Probability Scale" 
#| layout-ncol: 2
expDecay <- function(x, ActCue, filterSpeed, Baseline, scale = "prob") {
  y <- Baseline - ActCue * exp(-filterSpeed*x)
  if (scale == "prob") {
    brms::inv_logit_scaled(y)
  } else {
    y
  }
}

linBinding <- function(x, bindingAct, Baseline, scale = "prob") {
  y <- Baseline + bindingAct * x
  if (scale == "prob") {
    brms::inv_logit_scaled(y)
  } else {
    y
  }
}

BasePerformance <- function(x, Baseline, scale = "prob") {
  y <- Baseline + x*0
  
  if (scale == "prob") {
    brms::inv_logit_scaled(y)
  } else {
    y
  }
}


ggplot() +
  xlim(0,1) +
  geom_function(fun = expDecay,
                args = list(Baseline = 1.43, ActCue = 0.5, filterSpeed = 2.5, scale = "logit"),
                color = "darkred")  +
  geom_function(fun = linBinding,
                args = list(Baseline = 1.43, bindingAct = 0.5, scale = "logit"),
                color = "darkgreen") +
  geom_function(fun = BasePerformance,
                args = list(Baseline = 1.43, scale = "logit"),
                linetype = "dashed") +
  labs(y = "logit(p)",
       x = "CTI duration (s)",
       title = "Theoretical Model (Logit Scale)") +
  theme_bw() +
  theme(panel.grid.major.x  = element_blank(),
        panel.grid.minor.x = element_blank())

ggplot() +
  xlim(0,1) +
  geom_function(fun = expDecay,
                args = list(Baseline = 1.43, ActCue = 0.5, filterSpeed = 2.5),
                color = "darkred")  +
  geom_function(fun = linBinding,
                args = list(Baseline = 1.43, bindingAct = 0.5),
                color = "darkgreen") +
  geom_function(fun = BasePerformance,
                args = list(Baseline = 1.43),
                linetype = "dashed") +
  labs(y = "Proportion Correct",
       x = "CTI duration (s)",
       title = "Theoretical Model (Probability Scale)") +
  theme_bw() +
  theme(panel.grid.major.x  = element_blank(),
        panel.grid.minor.x = element_blank())
```

In addition, we included additive effects that reflected if a condition required that a saccade needed to be made away from the fixation or from the cue. This reflects differences between the NoSaccade condition and the Central Saccade condition. These effects were independent from the other theoretically motivated effects.

```{r LinearModel}
model_sat <- bf(correct | trials(nTrials) ~ 
                  # fixed effects
                  0 + Block + Block:CTI_num + 
                  # random effects
                  (0 + Block + Block:CTI_num | ID))

model_th_full <- bf(correct | trials(nTrials) ~ PercSpeed - 
                      inhibition * (InhibPro * exp(-exp(InhibReac)*CTI_num)) + 
                      binding * (bindingAct * CTI_num) +
                      bottomup * capture +
                      saccade * saccReq +
                      goalMain * FixDur_num,
                    PercSpeed  ~ 1 + (1 | r | ID),
                    goalMain   ~ 1 + (1 | r | ID),
                    capture    ~ 1 + (1 | r | ID),
                    saccReq    ~ 1 + (1 | r | ID),
                    InhibPro   ~ 1 + (1 | r | ID),
                    InhibReac  ~ 1 + (1 | r | ID),
                    bindingAct ~ 1 + (1 | r | ID),
                    nl = TRUE)

model_th_noPercSD <- bf(correct | trials(nTrials) ~ PercSpeed - 
                          inhibition * (InhibPro * exp(-exp(InhibReac)*CTI_num)) + 
                          binding * (bindingAct * CTI_num) +
                          bottomup * capture +
                          saccade * saccReq +
                          goalMain * FixDur_num,
                        PercSpeed  ~ 1,
                        goalMain   ~ 1 + (1 | r | ID),
                        capture    ~ 1 + (1 | r | ID),
                        saccReq    ~ 1 + (1 | r | ID),
                        InhibPro   ~ 1 + (1 | r | ID),
                        InhibReac  ~ 1 + (1 | r | ID),
                        bindingAct ~ 1 + (1 | r | ID),
                        nl = TRUE)

model_th_noGoalSD <- bf(correct | trials(nTrials) ~ PercSpeed - 
                          inhibition * (InhibPro * exp(-exp(InhibReac)*CTI_num)) + 
                          binding * (bindingAct * CTI_num) +
                          bottomup * capture +
                          saccade * saccReq +
                          goalMain * FixDur_num,
                        PercSpeed  ~ 1 + (1 | r | ID),
                        goalMain   ~ 1,
                        capture    ~ 1 + (1 | r | ID),
                        saccReq    ~ 1 + (1 | r | ID),
                        InhibPro   ~ 1 + (1 | r | ID),
                        InhibReac  ~ 1 + (1 | r | ID),
                        bindingAct ~ 1 + (1 | r | ID),
                        nl = TRUE)

model_th_noCapSD <- bf(correct | trials(nTrials) ~ PercSpeed - 
                         inhibition * (InhibPro * exp(-exp(InhibReac)*CTI_num)) + 
                         binding * (bindingAct * CTI_num) +
                         bottomup * capture +
                         saccade * saccReq +
                         goalMain * FixDur_num,
                       PercSpeed  ~ 1 + (1 | r | ID),
                       goalMain   ~ 1 + (1 | r | ID),
                       capture    ~ 1,
                       saccReq    ~ 1 + (1 | r | ID),
                       InhibPro   ~ 1 + (1 | r | ID),
                       InhibReac  ~ 1 + (1 | r | ID),
                       bindingAct ~ 1 + (1 | r | ID),
                       nl = TRUE)

model_th_noSacSD <- bf(correct | trials(nTrials) ~ PercSpeed - 
                         inhibition * (InhibPro * exp(-exp(InhibReac)*CTI_num)) + 
                         binding * (bindingAct * CTI_num) +
                         bottomup * capture +
                         saccade * saccReq +
                         goalMain * FixDur_num,
                       PercSpeed  ~ 1 + (1 | r | ID),
                       goalMain   ~ 1 + (1 | r | ID),
                       capture    ~ 1 + (1 | r | ID),
                       saccReq    ~ 1,
                       InhibPro   ~ 1 + (1 | r | ID),
                       InhibReac  ~ 1 + (1 | r | ID),
                       bindingAct ~ 1 + (1 | r | ID),
                       nl = TRUE)

model_th_noInhProSD <- bf(correct | trials(nTrials) ~ PercSpeed - 
                            inhibition * (InhibPro * exp(-exp(InhibReac)*CTI_num)) + 
                            binding * (bindingAct * CTI_num) +
                            bottomup * capture +
                            saccade * saccReq +
                            goalMain * FixDur_num,
                          PercSpeed  ~ 1 + (1 | r | ID),
                          goalMain   ~ 1 + (1 | r | ID),
                          capture    ~ 1 + (1 | r | ID),
                          saccReq    ~ 1 + (1 | r | ID),
                          InhibPro   ~ 1,
                          InhibReac  ~ 1 + (1 | r | ID),
                          bindingAct ~ 1 + (1 | r | ID),
                          nl = TRUE)

model_th_noInhReSD <- bf(correct | trials(nTrials) ~ PercSpeed - 
                           inhibition * (InhibPro * exp(-exp(InhibReac)*CTI_num)) + 
                           binding * (bindingAct * CTI_num) +
                           bottomup * capture +
                           saccade * saccReq +
                           goalMain * FixDur_num,
                         PercSpeed  ~ 1 + (1 | r | ID),
                         goalMain   ~ 1 + (1 | r | ID),
                         capture    ~ 1 + (1 | r | ID),
                         saccReq    ~ 1 + (1 | r | ID),
                         InhibPro   ~ 1 + (1 | r | ID),
                         InhibReac  ~ 1,
                         bindingAct ~ 1 + (1 | r | ID),
                         nl = TRUE)

model_th_noBindSD <- bf(correct | trials(nTrials) ~ PercSpeed - 
                          inhibition * (InhibPro * exp(-exp(InhibReac)*CTI_num)) + 
                          binding * (bindingAct * CTI_num) +
                          bottomup * capture +
                          saccade * saccReq +
                          goalMain * FixDur_num,
                        PercSpeed  ~ 1 + (1 | r | ID),
                        goalMain   ~ 1 + (1 | r | ID),
                        capture    ~ 1 + (1 | r | ID),
                        saccReq    ~ 1 + (1 | r | ID),
                        InhibPro   ~ 1 + (1 | r | ID),
                        InhibReac  ~ 1 + (1 | r | ID),
                        bindingAct ~ 1,
                        nl = TRUE)

model_th_final <- bf(correct | trials(nTrials) ~ PercSpeed - 
                          inhibition * (InhibPro * exp(-exp(InhibReac)*CTI_num)) + 
                          binding * (bindingAct * CTI_num) +
                          bottomup * capture +
                          saccade * saccReq +
                          goalMain * FixDur_num,
                        PercSpeed  ~ 1 + (1 | r | ID),
                        goalMain   ~ 1,
                        capture    ~ 1 + (1 | r | ID),
                        saccReq    ~ 1 + (1 | r | ID),
                        InhibPro   ~ 1,
                        InhibReac  ~ 1 + (1 | r | ID),
                        bindingAct ~ 1 + (1 | r | ID),
                        nl = TRUE)

model_th_reduced <- bf(correct | trials(nTrials) ~ PercSpeed - 
                         inhibition * (InhibPro * exp(-InhibReac*CTI_num)) + 
                         binding * (bindingAct * CTI_num) +
                         bottomup * capture +
                         saccade * saccReq +
                         goalMain * FixDur_num,
                       PercSpeed  ~ 1 + (1 | r | ID),
                       goalMain   ~ 1 + (1 | r | ID),
                       capture    ~ 1 + (1 | r | ID),
                       saccReq    ~ 1 + (1 | r | ID),
                       InhibPro   ~ 1 + (1 | r | ID),
                       InhibReac  ~ 1,
                       bindingAct ~ 1 + (1 | r | ID),
                       nl = TRUE)

all_model_formulas <- list(saturated = model_sat, 
                           th_full = model_th_full, 
                           noPercSD = model_th_noPercSD, 
                           noGoalSD = model_th_noGoalSD, 
                           noCapSD = model_th_noCapSD, 
                           noSacSD = model_th_noSacSD, 
                           noInhProSD =model_th_noInhProSD, 
                           noInhReSD = model_th_noInhReSD, 
                           noBindSD = model_th_noBindSD, 
                           reduced = model_th_reduced,
                           th_final = model_th_final)
```

For all model parameters, we used moderately informative normal priors centered on zero with a standard deviation of one. Parameters were estimated with four independent MCMC chains retaining 10000 samples for each chain after 2000 warm-up samples.

```{r Priors}
sat_priors <- prior("logistic(0,1)", class = b)
theoretical_priors <- prior("normal(0,1)", class = b, nlpar = PercSpeed) +
  prior("normal(0,1)", class = b, nlpar = goalMain) +
  prior("normal(0,1)", class = b, nlpar = capture) +
  prior("normal(0,1)", class = b, nlpar = saccReq) +
  prior("normal(0,1)", class = b, nlpar = InhibPro) +
  prior("normal(0,1)", class = b, nlpar = InhibReac) +
  prior("normal(0,1)", class = b, nlpar = bindingAct)
theoretical_priors_reduced <- prior("normal(0,1)", class = b, nlpar = PercSpeed) +
  prior("normal(0,1)", class = b, nlpar = goalMain) +
  prior("normal(0,1)", class = b, nlpar = capture) +
  prior("normal(0,1)", class = b, nlpar = saccReq) +
  prior("normal(0,1)", class = b, nlpar = InhibPro) +
  prior("constant(0)", class = b, nlpar = InhibReac) +
  prior("normal(0,1)", class = b, nlpar = bindingAct)
```

```{r sampling_settings}
nChains <- 4
warmup_samples <- 2000
postwarmup_samples <- 10000
```

# Results

## Descriptive Statistics

```{r TableDesc}
#| label: tbl-descriptivesCTI
#| tab-cap: "Desciptive statistiscs for the proportion correct in the different experimental conditions and each CTI condition."
table_CTI <- agg_data %>% 
  group_by(Block, CTI) %>% 
  summarise(Mean = mean(correct/nTrials),
            SD = sd(correct/nTrials),
            Min = min(correct/nTrials),
            Max = max(correct/nTrials),
            .groups = "drop")
table_CTI[,3:6] <- round(table_CTI[,3:6],2)

knitr::kable(table_CTI)
```

```{r TableDesc}
#| label: tbl-descriptivesFixDur
#| tab-cap: "Desciptive statistiscs for the proportion correct in the different experimental conditions and each Fixation duration condition."
table_FixDur <- agg_data %>% 
  group_by(Block, FixDur) %>% 
  summarise(Mean = mean(correct/nTrials),
            SD = sd(correct/nTrials),
            Min = min(correct/nTrials),
            Max = max(correct/nTrials),
            .groups = "drop")
table_FixDur[,3:6] <- round(table_FixDur[,3:6],2)
knitr::kable(table_FixDur)
```

The summary statistics for the Proportion of correct responses in the five different blocks for all CTI durations are given in @tbl-descriptivesCTI and @tbl-descriptivesFixDur. @fig-descriptive displays the average performance across the different conditions and includes performance of each subject in each of the conditions.

```{r FigDesc, echo=FALSE}
plot_data <- data %>%
  dplyr::group_by(ID, Block, bottomup, saccade, inhibition, binding, CTI, CTI_num) %>%
  dplyr::summarise(
    correct = sum(correct),
    nTrials = dplyr::n(),
    .groups = "drop"
  )

desc_plot <- ggplot(data = plot_data,
                    aes(x = as.factor(CTI_num*1000), y = correct/nTrials, color = as.factor(Block), fill = as.factor(Block), 
                        group = as.factor(Block), shape = as.factor(bottomup))) +
  facet_grid(inhibition ~ binding, labeller = label_both) +
  ggplot2::geom_jitter(position = ggplot2::position_jitterdodge(jitter.width = jitter_width, dodge.width = plot_dodge),
                       alpha = point_alpha) +
  stat_summary(position = position_dodge(plot_dodge), fun.data = mean_se) +
  ggplot2::stat_summary(geom = "line", fun = "mean", position = ggplot2::position_dodge(plot_dodge)) +
  geom_hline(yintercept = 0.33, color = "red", linetype = "dashed") +
  labs(x = "Cue-Target Interval",
       y = "Proportion Correct",
       color = "Block", fill = "Block",
       shape = "Pos Cue = Target",
       title = "Descriptive Plot") +
  coord_cartesian(ylim = c(0,1)) +
  theme_bw() +
  theme(panel.grid.major.x = element_blank())
ggsave(filename = "figures_E1/E1_Descriptives.jpg",desc_plot, dpi = 300, width = 7, height = 6)
```

![Average performance (circles and triangles) in the five experimental conditions for each level of CTI duration in Experiment 1. Conditions are grouped into panels by whether they require inhibition of a saccade (rows) and whether they afford using stimulus-response bindings between cue and target location to anticipate the target location (columns). The point clouds around each mean represent the subject estimates, and the dashed red line represents chance performance.](figures_E1/E1_Descriptives.jpg){#fig-descriptive}

## GLM: Accuracy

```{r FitModel}
for(i in 1:length(all_model_formulas)) {
  model_name <- names(all_model_formulas)[i]
  model_formula = all_model_formulas[[i]]
  
  if (model_name == "saturated") {
    priors <- sat_priors
  } else if(model_name == "reduced") {
    priors <- theoretical_priors_reduced
  } else {
    priors <- theoretical_priors
  }
  
  fitted_model <- brms::brm(model_formula,
                                  data = agg_data,
                                  family = model_family,
                                  backend = "cmdstanr",
                                  chains = nChains,
                                  iter = warmup_samples + postwarmup_samples, 
                                  warmup = warmup_samples,
                                  prior = priors,
                                  save_pars = save_pars(all = T),
                                  file = paste0("modelFits_E1/fit_E1_", model_name),
                                  file_refit = "on_change")
  
  prior_model <- brms::brm(model_formula,
                                 data = agg_data,
                                 family = model_family,
                                 backend = "cmdstanr",
                                 chains = nChains,
                                 iter = warmup_samples + postwarmup_samples, 
                                 warmup = warmup_samples,
                                 prior = priors,
                                 sample_prior = "only",
                                 save_pars = save_pars(all = T),
                                 file = paste0("modelFits_E1/fit_E1_", model_name,"_priors"),
                                 file_refit = "on_change")
  
  if (!file.exists(paste("modelFits_E1/bridge_E1_", model_name, ".rds", sep = ""))) {
    bridge <- bridge_sampler(fitted_model, cores = 4, repetitions = 10)
    saveRDS(bridge, paste("modelFits_E1/bridge_E1_", model_name, ".rds", sep = ""))
  }
}

rm(fitted_model, prior_model, bridge)
```

```{r BayesFactors SD}
marginalLL <- list()
for(i in 1:length(all_model_formulas)) {
  model_name <- names(all_model_formulas)[i]
  model_formula = all_model_formulas[[i]]
  marginalLL[[i]] <- readRDS(paste("modelFits_E1/bridge_E1_", model_name, ".rds", sep = ""))
}
names(marginalLL) <- names(all_model_formulas)

noSD_models <- names(marginalLL)[grepl("SD",names(marginalLL))]
bf_noSD <- data.frame(
  sd = noSD_models,
  median_bf = NaN,
  min_bf = NaN,
  max_bf = NaN
)

for(i in 1:length(noSD_models)) {
  bf <- bayes_factor(marginalLL[["th_full"]], marginalLL[[noSD_models[i]]])
  
  bf_noSD$median_bf[i] <- bf$bf_median_based
  bf_noSD$min_bf[i] <- min(bf$bf)
  bf_noSD$max_bf[i] <- max(bf$bf)
}
```

```{r ModelComparison}
bf_final <- bayes_factor(marginalLL$th_full, marginalLL$th_final)

fit_E1_th_full <- readRDS("~/Documents/GitHub/AntiSaccade/docs/modelFits_E1/fit_E1_th_full.rds")
fit_E1_th_full_priors <- readRDS("~/Documents/GitHub/AntiSaccade/docs/modelFits_E1/fit_E1_th_full_priors.rds")

fit_E1_th_final <- readRDS("~/Documents/GitHub/AntiSaccade/docs/modelFits_E1/fit_E1_th_final.rds")
fit_E1_th_final_priors <- readRDS("~/Documents/GitHub/AntiSaccade/docs/modelFits_E1/fit_E1_th_final_priors.rds")

fit_E1_saturated <- readRDS("~/Documents/GitHub/AntiSaccade/docs/modelFits_E1/fit_E1_saturated.rds")

# Test if parameters differ from zero
bf_pars <- bayestestR::bayesfactor_parameters(fit_E1_th_final,
                                              prior = fit_E1_th_final_priors)

# test if there is evidence for filtering
bf_filter <- bayes_factor(marginalLL$noInhProSD, marginalLL$reduced)

# extract fixed effect for theoretical model
fixFX <- round(fixef(fit_E1_th_full),2)

# plot posterior predictives: saturated model
newdata_saturated <- expand.grid(
  ID = unique(agg_data$ID),
  nTrials = 1,
  CTI_num = unique(agg_data$CTI_num),
  Block = unique(agg_data$Block)
)

tidy_pred_sat <- fit_E1_saturated %>% 
  tidybayes::epred_draws(newdata = newdata_saturated, ndraws = 1000) %>% 
  group_by(ID, CTI_num, Block) %>% 
  summarise(predValue = mean(.epred)) %>% 
  left_join(Block2Conds) %>% 
  filter(!is.na(Block))

pp_plot_sat <- ggplot(data = tidy_pred_sat,
                      aes(x = as.factor(CTI_num*1000), y = predValue, color = as.factor(Block), fill = as.factor(Block), 
                          group = as.factor(Block), shape = as.factor(bottomup))) +
  facet_grid(inhibition ~ binding, labeller = label_both) +
  ggplot2::geom_jitter(position = ggplot2::position_jitterdodge(jitter.width = jitter_width, dodge.width = plot_dodge),
                       alpha = point_alpha) +
  stat_summary(position = position_dodge(plot_dodge), fun.data = mean_se) +
  ggplot2::stat_summary(geom = "line", fun = "mean", position = ggplot2::position_dodge(plot_dodge)) +
  stat_summary(geom = "point", fun = mean, position = position_dodge(plot_dodge),
               data = agg_data, color = "black", shape = "cross",
               aes(x = as.factor(CTI_num*1000), y = correct/nTrials)) +
  geom_hline(yintercept = 0.33, color = "red", linetype = "dashed") +
  labs(x = "Cue-Target Interval",
       y = "Proportion Correct",
       color = "Block", fill = "Block",
       shape = "Pos Cue = Target",
       title = "Posterior Predictives (Saturated)") +
  coord_cartesian(ylim = c(0,1)) + theme_bw() +
  theme(panel.grid.major.x = element_blank())
ggsave(filename = "figures_E1/PostPredictives_Saturated_E1.jpg",pp_plot_sat, dpi = 300, width = 7, height = 6)


newdata_theoretical <- expand.grid(
  ID = unique(agg_data$ID),
  nTrials = 1,
  CTI_num = unique(agg_data$CTI_num),
  FixDur_num = unique(agg_data$FixDur_num),
  binding = unique(agg_data$binding),
  inhibition = unique(agg_data$inhibition),
  saccade = unique(agg_data$saccade),
  bottomup = unique(agg_data$bottomup)
) %>% 
  left_join(Block2Conds) %>% 
  filter(!is.na(Block))


tidy_pred_theoretical <- fit_E1_th_full %>% 
  tidybayes::epred_draws(newdata = newdata_theoretical, ndraws = 1000) %>% 
  group_by(ID, CTI_num, binding, inhibition, saccade, bottomup) %>% 
  summarise(predValue = mean(.epred)) %>% 
  left_join(Block2Conds) %>% 
  filter(!is.na(Block))

pp_plot_theoretical <- ggplot(data = tidy_pred_theoretical,
                              aes(x = as.factor(CTI_num*1000), y = predValue, color = as.factor(Block), fill = as.factor(Block), 
                                  group = as.factor(Block), shape = as.factor(bottomup))) +
  facet_grid(inhibition ~ binding, labeller = label_both) +
  ggplot2::geom_jitter(position = ggplot2::position_jitterdodge(jitter.width = jitter_width, dodge.width = plot_dodge),
                       alpha = point_alpha) +
  ggplot2::stat_summary(geom = "line", fun = "mean", position = ggplot2::position_dodge(plot_dodge)) +
  stat_summary(position = position_dodge(plot_dodge), fun.data = mean_se) +
  stat_summary(geom = "point", fun = mean, position = position_dodge(plot_dodge),
               data = agg_data, color = "black", shape = "cross",
               aes(x = as.factor(CTI_num*1000), y = correct/nTrials)) +
  geom_hline(yintercept = 0.33, color = "red", linetype = "dashed") +
  labs(x = "Cue-Target Interval (in ms)",
       y = "Proportion Correct",
       color = "Block", fill = "Block",
       shape = "Pos Cue = Target",
       title = "Posterior Predictives (Theoretical)") +
  coord_cartesian(ylim = c(0,1)) + theme_bw() +
  theme(panel.grid.major.x = element_blank())
ggsave(filename = "figures_E1/PostPredictives_Theoretical_E1.jpg",pp_plot_theoretical, dpi = 300, width = 7, height = 6)
```

### Experimental Effects

![Posterior predictives of the average proportion correct as a function of CTI duration. The black crosses indicate the observed average proportion correct. The point cloud around the posterior means represent the subject estimates in each condition, and the dashed red line indicates guessing performance.](figures_E1/PostPredictives_Theoretical_E1.jpg){#fig-predictive}

@fig-predictive shows the posterior predictive estimates from the Bayesian GLM for the different experimental blocks and the changes in performance across the different CTI levels on the proportion correct scale. The theoretical model fits adequately to the observed data, as indicated by the black crosses in the plot that closely overlay with the posterior means estimated from the GLM.

First, we evaluated if there was evidence for the different theoretically assumed processes contributing to performance in the manual anti-Saccade task. There was a credible effect of the need to inhibit a reflexive saccade, $b_{InhibPro} = `r fixFX["InhibPro_Intercept","Estimate"]`$, 95% CI = $[`r fixFX["InhibPro_Intercept","Q2.5"]`;`r fixFX["InhibPro_Intercept","Q97.5"]`]$, $BF_{10} =$ `r printnum(exp(bf_pars[which(bf_pars[,"Parameter"] == "b_InhibPro_Intercept"),"log_BF"]), format = "g")`, which weakened with longer CTI duration, $b_{InhibReac} = `r round(exp(fixFX["InhibReac_Intercept","Estimate"]),2)`$, 95% CI = $[`r exp(fixFX["InhibReac_Intercept","Q2.5"])`;`r exp(fixFX["InhibReac_Intercept","Q97.5"])`]$, $BF_{10} =$ `r printnum( bf_filter[["bf_median_based"]], format = "g")`. Likewise, a regular relationship between the cue and the location of the target improved performance with longer CTI duration, $b_{Binding} = `r fixFX["bindingAct_Intercept","Estimate"]`$, 95% CI = $[`r fixFX["bindingAct_Intercept","Q2.5"]`;`r fixFX["bindingAct_Intercept","Q97.5"]`]$, $BF_{10} =$ `r printnum(exp(bf_pars[which(bf_pars[,"Parameter"] == "b_bindingAct_Intercept"),"log_BF"]), format = "g")`. In addition, having to perform a saccade, $b_{saccade} = `r fixFX["saccReq_Intercept","Estimate"]`$, 95% CI = $[`r fixFX["saccReq_Intercept","Q2.5"]`;`r fixFX["saccReq_Intercept","Q97.5"]`]$, $BF_{10} =$ `r printnum(exp(bf_pars[which(bf_pars[,"Parameter"] == "b_saccReq_Intercept"),"log_BF"]), format = "g")`. resulted in worse performance. Further, performance was better when cue and target location coincided, showing a benefit from being able to rely on automatic attraction of attention to the cue location, $b_{BottomUp} = `r fixFX["capture_Intercept","Estimate"]`$, 95% CI = $[`r fixFX["capture_Intercept","Q2.5"]`;`r fixFX["capture_Intercept","Q97.5"]`]$, $BF_{10} =$ `r printnum(exp(bf_pars[which(bf_pars[,"Parameter"] == "b_capture_Intercept"),"log_BF"]), format = "g")`, resulted in worse performance. There was also a credible benefit from a longer preparation interval, $b_{GoalMain} = `r fixFX["goalMain_Intercept","Estimate"]`$, 95% CI = $[`r fixFX["goalMain_Intercept","Q2.5"]`;`r fixFX["goalMain_Intercept","Q97.5"]`]$, $BF_{10} =$ `r printnum(exp(bf_pars[which(bf_pars[,"Parameter"] == "b_goalMain_Intercept"),"log_BF"]), format = "g")`. A summary of parameter estimates is displayed in @tbl-parameters.

```{r ParTable}
#| label: tbl-parameters
#| tab-cap: "Overview of parameter estimates"
rownames(fixFX) <- stringr::str_remove(rownames(fixFX), "_Intercept")
fixFX["InhibReac",]<- exp(fixFX["InhibReac",])

corr_est <- VarCorr(fit_E1_th_full)$ID
sdFX <- round(corr_est$sd,2)
row.names(sdFX) <- stringr::str_remove(row.names(sdFX),"_Intercept")

allFX <- cbind(fixFX, sdFX)
knitr::kable(allFX[,c(1,3:5,7:8)], digits = 2)
```

### Individual Differences

```{r}
#| label: tbl-bfSD
#| tab-cap: "Bayes Factors in favor of individual differences in the processes seperated."
# test if there is evidence for individual differences in the different processes
knitr::kable(bf_noSD)
```

As the manual Anti-Saccade task is commonly used in individual differences research to measure how people differ in their ability to control attention and how this is related to other cognitive abilities, we also tested if there are credible individual differences in the processes we dissociated in our model. The estimates for the standard deviation of the dissociated processes across individuals are shown in @tbl-parameters. As standard deviations were estimated with a lower bound of zero, we tested if random effects were credible by selectively fixing the random effect of one of the processes to zero and test if this model was favored over a model freely estimating the random effect. These analyses indicated that there was credible evidence for individual differences in all but two processes separated in the model (see @tbl-bfSD). Only for the random effect of goal maintenance and proactive inhibition of reflexive saccades, the Bayes Factors indicated that there was no or no consistent credible variation across individuals. Therefore, we fixed both these random effect to zero for the following analyses. The model with the fixed random effects was favored over the model with freely estimated random effects, $BF =$ `r printnum(1/bf_final$bf_median_based, format = "g")`.

We estimated the correlations between the random effects that were retained in this final model. @tbl-correlations shows the estimated standard deviations of all random effects and the correlations among them. Generally, correlations between random effects were small, most $|r_s| < .30$, except for the correlation between perceptual speed and the cost of having to performing a saccade towards the target, $r = -.76$. However, the generally small correlations indicate that the different cognitive processes seperated in our theoretical model are mostly independent from one another.

```{r CorrTable}
#| label: tbl-correlations
#| tab-cap: "Correlations between random effects. Values on the diagonal represent the posterior estimates of the standard deviation of each random effect."
corr_est <- VarCorr(fit_E1_th_final)$ID

cormat <- matrix(NA, nrow = nrow(corr_est$sd), ncol = nrow(corr_est$sd))

for (i in 1:dim(corr_est$cor)[3]){
  cormat[i,] <- corr_est$cor[,"Estimate",i]
}

rownames(cormat) <- stringr::str_remove(dimnames(corr_est$cor)[[3]],"_Intercept")
colnames(cormat) <- stringr::str_remove(dimnames(corr_est$cor)[[3]],"_Intercept")
diag(cormat) <- corr_est$sd[,"Estimate"]
cormat <- round(cormat,2)
cormat[upper.tri(cormat)] <- ""
knitr::kable(cormat, digits = 2)
```

### Validity of the Anti-Saccade Task

Since its conception the anti-saccade task was used as a measure for the ability to inhibit automatic saccade. To test if this is true, we investigated how strongly performance in the difference experimental conditions was related to the processes we dissociated in the GLM.

@fig-validity shows a summary of correlations between 100 random draws of the random effects of the processes separated in the GLM with the observed performance in the different experimental blocks. These correlations capture to what extend performance in one of the experimental blocks is a valid indicator for the processes. A process pure indicator would only correlate with one of the process measures. As is evident from the figure, none of the experimental blocks is a truly process pure indicator for a single process. With respect to the typical use of the anti-saccade task (using a CTI of 50ms), it is measuring at least three processes: 1) perceptual speed, 2) re-actively inhibiting the reflexive saccade elicited by the cue onset, and 3 binding ability. In consequence, any correlation of the anti-saccade task with external covariates can thus stem from a correlation with any of these processes. This renders the interpretation of the predictive power of performance in the anti-saccade task complex to interpret with respect to the processes that is responsible for it.

```{r}
#| label: fig-validity
#| fig-cap: "Validity estimates of performance in the different conditions for the seperated processes."
agg_data_validity <- data %>%
  dplyr::group_by(ID, Block, CTI) %>%
  dplyr::summarise(
    pC = mean(correct),
    .groups = "drop"
  )

randFX_draws <- fit_E1_th_final %>% 
  tidybayes::gather_draws(r_ID__PercSpeed[ID,],
                          r_ID__capture[ID,],
                          r_ID__saccReq[ID,],
                          r_ID__InhibReac[ID,], 
                          r_ID__bindingAct[ID,],
                          ndraws = 100) %>% 
  mutate(.variable = stringr::str_remove(.variable, "r_ID__"))

randFX_draws <- randFX_draws %>% 
  tidyr::pivot_wider(names_from = c(.variable),
                     values_from = .value)

df_validity = expand.grid(
  ID = unique(agg_data_validity$ID),
  Block = unique(agg_data_validity$Block),
  CTI = unique(agg_data_validity$CTI),
  .chain = unique(randFX_draws$.chain),
  .iteration = unique(randFX_draws$.iteration),
  .draw = unique(randFX_draws$.draw)
) %>% left_join(agg_data_validity, by = c("ID","Block","CTI")) %>% 
  left_join(randFX_draws, by = c("ID",".chain",".draw",".iteration"))

df_cor <- df_validity %>% 
  group_by(Block, CTI, .draw) %>% 
  summarise(
    PercSpeed = cor(pC, PercSpeed, use = "complete.obs"),
    InhibReac = cor(pC, InhibReac, use = "complete.obs"),
    Binding = cor(pC, bindingAct, use = "complete.obs"),
    Capture = cor(pC, capture, use = "complete.obs"),
    Saccade = cor(pC, saccReq, use = "complete.obs"),
    .groups = "drop") %>% 
  tidyr::pivot_longer(cols = c(PercSpeed, InhibReac, Binding, Capture, Saccade)) %>% 
  group_by(Block, CTI, name) %>% 
  summarise(
    mean = mean(value),
    CIlow = quantile(value, probs = 0.025),
    CIhigh = quantile(value, probs = 0.975)
  )

df_cor$process = "yes"

df_cor[which(df_cor$name == "InhibReac"),]$process <- ifelse(
  df_cor[which(df_cor$name == "InhibReac"),]$Block %in% inhib_blocks, "yes", "no")
df_cor[which(df_cor$name == "Binding"),]$process <- ifelse(
  df_cor[which(df_cor$name == "Binding"),]$Block %in% bind_blocks, "yes", "no")
df_cor[which(df_cor$name == "Saccade"),]$process <- ifelse(
  df_cor[which(df_cor$name == "Saccade"),]$Block %in% saccade_blocks, "yes", "no")
df_cor[which(df_cor$name == "Capture"),]$process <- ifelse(
  df_cor[which(df_cor$name == "Capture"),]$Block %in% bottomup_blocks, "yes", "no")

plot_validity <- ggplot(data = df_cor,
                        aes(x = as.factor(CTI), y = mean, ymin = CIlow, ymax = CIhigh, color = Block, shape = process, alpha = process)) +
  geom_point(position = position_dodge(0.5), size =2) +
  geom_errorbar(width = 0, position = position_dodge(0.5), linewidth = 1) +
  facet_wrap(~name) +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  scale_alpha_discrete(range = c(1/3,1)) +
  labs(x = "Cue-Target Interval", y = "Validity (Correlation: Process with Prop. Corr)",
       shape = "Process\n included:", alpha = "Process\n included:") +
  theme_bw() +
  theme(panel.grid.major.x = element_blank())

ggsave(filename = "figures_E1/Validity_E1.jpg",plot_validity, dpi = 300, width = 7, height = 6)
knitr::include_graphics("figures_E1/Validity_E1.jpg")
```
