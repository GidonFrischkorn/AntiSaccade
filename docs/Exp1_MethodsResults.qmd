---
title: "Experiment 1: Method & Results"
format: docx
editor: visual
editor_options: 
  chunk_output_type: console
---

```{r options, include = FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  echo = FALSE,
  output = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  collapse = TRUE
)
```

```{r setup}
pacman::p_load(AntiSaccade, papaja, brms, dplyr, ggplot2, here, lavaan)
options(mc.cores = parallel::detectCores())

# plot settings
plot_dodge <- 1
jitter_width <- 1
point_alpha <- 0.1
```

# Methods

```{r data_prep}
data <- RawData_Exp5
nSub_total <- length(unique(data$ID))
data$CTI_num <- (data$CTI)/100
data$CTI <- as.factor(data$CTI)
data$RTms <- data$RTms + 150

levels(data$Block) <- stringr::str_replace_all(levels(data$Block), "[:digit:]", "")

inhib_blocks <- c("Anti","Random")
bind_blocks <- c("Pro","Anti","Colour")
SaccadeFromCue <- c("Anti","Random","Central")
SaccadeFromFixation <- c("Pro","Anti","Random","Central")

Block2Conds <- data.frame(
  Block = unique(data$Block)
)

data$inhibition <- ifelse(data$Block %in% inhib_blocks,1,0)
data$binding <- ifelse(data$Block %in% bind_blocks,1,0)
data$SaccadeFromCue <- ifelse(data$Block %in% SaccadeFromCue,1,0)
data$SaccadeFromFixation <- ifelse(data$Block %in% SaccadeFromFixation,1,0)

Block2Conds$inhibition <- ifelse(Block2Conds$Block %in% inhib_blocks,1,0)
Block2Conds$binding <- ifelse(Block2Conds$Block %in% bind_blocks,1,0)
Block2Conds$SaccadeFromCue <- ifelse(Block2Conds$Block %in% SaccadeFromCue,1,0)
Block2Conds$SaccadeFromFixation <- ifelse(Block2Conds$Block %in% SaccadeFromFixation,1,0)

outlier_data <- data %>% 
  group_by(ID, Block, CTI) %>% 
  summarise(meanPC = mean(correct),
            nTrials = n(),
            .groups = "drop") %>% 
  group_by(Block,CTI) %>% 
  mutate(
    meanPC_logit = logit_scaled(meanPC - (0.5/nTrials)),
    zPC_logit = (meanPC_logit - mean(meanPC_logit))/sd(meanPC_logit))
outlier_IDs2 <- unique(outlier_data$ID[which(outlier_data$meanPC <= qbinom(p = .95, size = outlier_data$nTrials, prob = 1/3)/outlier_data$nTrials)])
outlier_IDs <- unique(outlier_data$ID[which(outlier_data$zPC_logit <= qnorm(p = .01))])

data <- data %>% 
  filter(!ID %in% outlier_IDs)
nSub <- length(unique(data$ID))

# aggregate data for binomial models
agg_data <- data %>%
  dplyr::group_by(ID, Block, SaccadeFromCue, SaccadeFromFixation, inhibition, binding, CTI, CTI_num) %>%
  dplyr::summarise(
    correct = sum(correct),
    nTrials = dplyr::n(),
    .groups = "drop"
  )
```

## Participants

We recruited `r papaja::printnum(nSub_total)` participants via Prolific, `r nSub_total - nSub` participants were excluded for low performance, thus `r papaja::printnum(nSub)` participants were included in the data analyses. Participants were required to be 18 to 40 years old, speak English as their first language, and have an approval rate of at least 85% when participating in studies on Prolific.

## Design

This study was designed to isolate different processes contributing to performance in the manual anti saccade task. For this, we adapted previous versions of the manual anti-saccade (Kane et al., 2001) and increased the peripheral locations the target stimulus could appear in from 2 (left and right) to 4 (left, right, top, and bottom). This enabled us to introduce new experimental blocks in addition to the traditional Pro- and Anti-Saccade Blocks. Specifically, in this experiment, we included 3 additional blocks: a No-Saccade Block in which both the cue and the target appeared in the center of the screen, a Random Saccade Block in which the target could appear in any of the non-cued location, and a Central-Saccade Block in which the cue appeared in the center and the target could appear in any of the four peripheral locations. For an illustration of the manipulation implemented in these experimental blocks see Figure @fig-conditions.

![Illustration of the different experimental blocks. The top row exemplifies one of the locations the cue could appear in, and the bottom row highlights in which locations the target could appear in.](Conditions_Exp5.png){#fig-conditions fig-align="center"}

The idea underlying these different blocks is to systematically vary if participants need to inhibit automatic saccades towards the cue, and if the location the cue appears in is informative with respect to the target location. Thus, as already discussed in the introduction they require different processes that might be related to performance in the manual anti-saccade task. In detail, the No-Saccade block only requires to quickly discriminate between the target letters without any demands on controlling saccades and moving the eyes. The Pro-Saccade block adds the demands of performing a saccade to the cued locations. This could happen automatically or controlled. But it does not require to inhibit the automatic saccade. The Anti-Saccade block requires subjects to move their gaze to the opposite location of where the cue appeared. This requires inhibiting the automatic saccade elicited by the transient onset signal of the cue, and performing a controlled saccade to the opposite location. The Random saccade block require to inhibit the automatic saccade towards the cue, but does not allow for a controlled saccade towards the target location as it can not be inferred from the location the cue appeared in. Finally, the Central block neither requires to inhibit an automatic saccade, as the cue appears in the center, but also does not allow for a controlled saccade as the cue is not informative for the target location. But unlike in the No-Saccade condition the target does appear in one of the peripheral locations, thus only the transient onset signal of the target will draw attention towards the target location.

In addition, the blocks also differ in their requirements to perform saccades away from Fixation or from the Cue to detect the target letter. We included these factors, as they result in costs that occur because attention is partly guided by the transient onset signal of the cue. We aimed to separate these more exogenous processes of guiding attention, from the endogenous processes that are supposedly relying on attention control. An overview, of which processes were required in the different experimental blocks is shown in @tbl-Block2Proc

```{r Blocks2Procs}
#| label: tbl-Block2Proc
#| tab-cap: "Processes required by the different experimental blocks."
Table_Blocks2Procs <- Block2Conds %>% 
  mutate(SensoryDisc = 1) %>% 
  select(Block, SensoryDisc, inhibition, binding, SaccadeFromFixation, SaccadeFromCue)

Table_Blocks2Procs[,2:6] <- ifelse(Table_Blocks2Procs[,2:6] == 1, "yes","no")
Table_Blocks2Procs <- Table_Blocks2Procs[c(2,3,1,4,5),]
colnames(Table_Blocks2Procs) <- c("Block", "Sensory Disc.", "Inhibition", "Binding", "Saccade from Fixation", "Saccade from Cue")
knitr::kable(Table_Blocks2Procs)
```

In addition, we varied the Cue-Traget Innterval in three levels: 50, 200, 400ms to evaluate if longer time to inhibit automatic saccades towards the cued-location when required and use the location of the cue to perform a controlled saccade when possible improves performance.[^1]

[^1]: We examined the different ranges of CTI durations in two pilot experiments (Experiments S1 & 2 in the online supplement) in three of the five experimental blocks (i.e. the Pro, Anti, and Random Saccade blocks). The results of these two experiments suggested that a range from 50 to 400 ms covers the CTI effects well.

## Trial Procedure

Each trial started with a fixation cross that was presented for a variable fixation duration from 200 to 1400 ms in steps of 400 ms. After the fixation cross the cue was presented either in one of the four peripheral locations or in the center (only for the No-Saccade Block). The cue, a "=" appeared for 100 ms, then offset for 50 ms, and appeared again for 100 ms. This flickering was done to increase the transient signal of the cue and maximize the elicitation of automatic saccades (Kane et al., 2001). The screen then was blank for a CTI of 50, 200, or 400ms. After that the target letter - either a "P", "B", or "R" - appeared for 100ms in one of the peripheral locations or in the center according to the specified rules for the current block. The target letter was then backward masked with an "H" appearing for 50ms immediately followed by an "8" remaining on screen until participants responded which letter they detected by pressing "P", "B", or "R" on the keyboard. For an illustration of the trial procedures see Figure @fig-trial)

![Illustration of the trial procedure.](Figure_SaccadeTask2.png){#fig-trial fig-align="center"}

For each trial, we recorded the response given as well as the response time as the time between onset of the target stimulus until the response. In each block we ran 144 trials, so that each of the three target letters, appeared once in each of the four peripheral locations with each of the four fixation durations and three CTIs.

## Data Analysis

```{r CleanData}
n_full <- nrow(data)
data <- data %>% filter(RTms > 150, RTms < 5000)
n_filter <- nrow(data)

prop_filter <- (1 - n_filter/n_full) * 100
```

Prior to data analysis we removed trials with reaction times shorter than 150 ms and longer than 5000ms. This resulted in discarding `r papaja::printnum(prop_filter)`% of data.

We analyzed the number of correct responses with a Bayesian Generalized Linear Model assuming the number of correct responses follows a binomial distribution. We used a logit link function, thus estimating the linear model on the logit-scale. The model was estimated using the R package `brms`.

```{r model_family}
model_family <- brmsfamily("binomial", link = "logit")
```

To incorporate the theoretical assumptions outlined in the introduction, we specified that:

1.  conditions requiring the inhibition of the cued location (i.e. the Anti- and Random-Saccade block) would be lower in performance due to automatic activation from the cue $A_{cue}$. The lower this activation, the better a person is to avoid attention being captured by the cue. In theoretical terms differences between individuals in this activation from the cue represent pro-active control.
2.  automatic activation of the cue could be filtered out over time. This was implemented with an exponential decay function, reflecting that a certain proportion of cue activation gets filtered over time. The higher this filtering $f$, the better a person is to re-actively control attention and reduce activation from the cue over time.[^2]
3.  informative associations of cues to the target locations (in the Pro- and Anti-Saccade Block) could be used to improve performance over time. This binding activation $A_{binding}$ reflects a persons ability to use the association of the cued location to the target location to endogenously direct attention towards the cued location and improve the performance. We assumed that this process unfolds linearly with longer CTI duration.

[^2]: We chose to implement filtering this way, as two pilot experiments (Experiment S3 & 4 in the online supplement) have shown that participants only disengage attention from the cued location in the Random Saccade block, to redirect it towards the center of the screen, instead of entirely removing the cued location from the potential candidate positions the target could appear in. The latter could have resulted in a benefit for the Random Saccade Block over longer CTIs compared to the Central Saccade block, whereas the former only reduced the Cue Activiation down to the baseline level that we measure in the Central Saccade Block.

Formally, this resulted in the following model:

$$
p_{correct} = Baseline - A_{cue} * e^{-f*CTI} + A_{binding} * CTI
$$

For an illustration of these theoretically informed processes, see @fig-theory. Specifically, the black line represents baseline performance independent of the above mentioned processes, that is performance in the Random Saccade Block. The differences at time 0 between the black and the red line represents the automatic activation of the cue, that declines exponentially towards the black line with time. The green line represents the use of binding information over time that improves performance with longer CTI duration. As this model was implemented on the logit-scale, the increases in performance on the probability scale are non-linear for binding benefits as a result of the logit link function.

```{r Fig_TheoreticalModel}
#| label: fig-theory
#| fig-cap: "Illustration of the theoretically assumed processes and how they are affected by time."
#| fig-subcap:
#|   - "Probability Scale"
#|   - "Logit Scale" 
#| layout-ncol: 2
expDecay <- function(x, ActCue, filterSpeed, Baseline, scale = "prob") {
  y <- Baseline - ActCue * exp(-filterSpeed*x)
  if (scale == "prob") {
    brms::inv_logit_scaled(y)
  } else {
    y
  }
}

linBinding <- function(x, bindingAct, Baseline, scale = "prob") {
  y <- Baseline + bindingAct * x
  if (scale == "prob") {
    brms::inv_logit_scaled(y)
  } else {
    y
  }
}

BasePerformance <- function(x, Baseline, scale = "prob") {
  y <- Baseline + x*0
  
  if (scale == "prob") {
    brms::inv_logit_scaled(y)
  } else {
    y
  }
}


ggplot() +
  xlim(0,4) +
  geom_function(fun = expDecay,
                args = list(Baseline = 1.43, ActCue = 0.5, filterSpeed = 0.5, scale = "logit"),
                color = "darkred")  +
  geom_function(fun = linBinding,
                args = list(Baseline = 1.43, bindingAct = 0.2, scale = "logit"),
                color = "darkgreen") +
  geom_function(fun = BasePerformance,
                args = list(Baseline = 1.43, scale = "logit"),
                linetype = "dashed") +
  labs(y = "logit(p)",
       x = "CTI duration",
       title = "Theoretical Model (Logit Scale)") +
  theme_bw() +
  theme(panel.grid.major.x  = element_blank(),
        panel.grid.minor.x = element_blank())

ggplot() +
  xlim(0,4) +
  geom_function(fun = expDecay,
                args = list(Baseline = 1.43, ActCue = 0.62, filterSpeed = 0.5),
                color = "darkred")  +
  geom_function(fun = linBinding,
                args = list(Baseline = 1.43, bindingAct = 0.20),
                color = "darkgreen") +
  geom_function(fun = BasePerformance,
                args = list(Baseline = 1.43)) +
  labs(y = "Proportion Correct",
       x = "CTI duration",
       title = "Theoretical Model (Probability Scale)") +
  theme_bw() +
  theme(panel.grid.major.x  = element_blank(),
        panel.grid.minor.x = element_blank())
```

In addition, we included additive effects on the Baseline performance that reflected if a condition required that a saccade needed to be made away from the fixation or from the cue. This reflects differences between the NoSaccade condition and the Central Saccade condition. These effects were independent from the other theoretically motivated effects.

```{r LinearModel}
model_sat <- bf(correct | trials(nTrials) ~ 
                  # fixed effects
                  0 + Block + Block:CTI_num + 
                  # random effects
                  (0 + Block + Block:CTI_num | ID))

model_th_full <- bf(correct | trials(nTrials) ~ Baseline - 
                      inhibition*(ActCue * exp(-exp(filterSpeed)*CTI_num)) + 
                      binding*(bindingAct*CTI_num),
                    Baseline ~ 1 + SaccadeFromCue + SaccadeFromFixation +
                      (1 + SaccadeFromCue + SaccadeFromFixation  |r| ID),
                    ActCue ~ 1 + (1 |r| ID),
                    filterSpeed ~ 1 + (1 |r| ID),
                    bindingAct ~ 1 + (1 |r| ID),
                    nl = TRUE
)

model_th_noBaseSD <- bf(correct | trials(nTrials) ~ Baseline - 
                          inhibition*(ActCue * exp(-exp(filterSpeed)*CTI_num)) + 
                          binding*(bindingAct*CTI_num),
                        Baseline ~ 1 + SaccadeFromCue + SaccadeFromFixation +
                          (0 + SaccadeFromCue + SaccadeFromFixation  |r| ID),
                        ActCue ~ 1 + (1 |r| ID),
                        filterSpeed ~ 1 + (1 |r| ID),
                        bindingAct ~ 1 + (1 |r| ID),
                        nl = TRUE
)

model_th_noSfCSD <- bf(correct | trials(nTrials) ~ Baseline - 
                         inhibition*(ActCue * exp(-exp(filterSpeed)*CTI_num)) + 
                         binding*(bindingAct*CTI_num),
                       Baseline ~ 1 + SaccadeFromCue + SaccadeFromFixation +
                         (1 + SaccadeFromFixation  |r| ID),
                       ActCue ~ 1 + (1 |r| ID),
                       filterSpeed ~ 1 + (1 |r| ID),
                       bindingAct ~ 1 + (1 |r| ID),
                       nl = TRUE
)

model_th_noSfFSD <- bf(correct | trials(nTrials) ~ Baseline - 
                         inhibition*(ActCue * exp(-exp(filterSpeed)*CTI_num)) + 
                         binding*(bindingAct*CTI_num),
                       Baseline ~ 1 + SaccadeFromCue + SaccadeFromFixation +
                         (1 + SaccadeFromCue  |r| ID),
                       ActCue ~ 1 + (1 |r| ID),
                       filterSpeed ~ 1 + (1 |r| ID),
                       bindingAct ~ 1 + (1 |r| ID),
                       nl = TRUE
)

model_th_noAcSD <- bf(correct | trials(nTrials) ~ Baseline - 
                        inhibition*(ActCue * exp(-exp(filterSpeed)*CTI_num)) + 
                        binding*(bindingAct*CTI_num),
                      Baseline ~ 1 + SaccadeFromCue + SaccadeFromFixation +
                        (1 + SaccadeFromCue + SaccadeFromFixation  |r| ID),
                      ActCue ~ 1 ,
                      filterSpeed ~ 1 + (1 |r| ID),
                      bindingAct ~ 1 + (1 |r| ID),
                      nl = TRUE
)

model_th_noFSD <- bf(correct | trials(nTrials) ~ Baseline - 
                       inhibition*(ActCue * exp(-exp(filterSpeed)*CTI_num)) + 
                       binding*(bindingAct*CTI_num),
                     Baseline ~ 1 + SaccadeFromCue + SaccadeFromFixation +
                       (1 + SaccadeFromCue + SaccadeFromFixation  |r| ID),
                     ActCue ~ 1 + (1 |r| ID),
                     filterSpeed ~ 1,
                     bindingAct ~ 1 + (1 |r| ID),
                     nl = TRUE
)

model_th_noBindSD <- bf(correct | trials(nTrials) ~ Baseline - 
                          inhibition*(ActCue * exp(-exp(filterSpeed)*CTI_num)) + 
                          binding*(bindingAct*CTI_num),
                        Baseline ~ 1 + SaccadeFromCue + SaccadeFromFixation +
                          (1 + SaccadeFromCue + SaccadeFromFixation  |r| ID),
                        ActCue ~ 1 + (1 |r| ID),
                        filterSpeed ~ 1 + (1 |r| ID),
                        bindingAct ~ 1,
                        nl = TRUE
)

model_th_reduced <- bf(correct | trials(nTrials) ~ Baseline - 
                         inhibition*(ActCue) * exp(-filterSpeed*CTI_num)  + 
                         binding*(bindingAct*CTI_num),
                       Baseline ~ 1 + SaccadeFromCue + SaccadeFromFixation +
                         (1 + SaccadeFromCue + SaccadeFromFixation  |r| ID),
                       ActCue ~ 1 + (1 |r| ID),
                       filterSpeed ~ 1,
                       bindingAct ~ 1 + (1 |r| ID),
                       nl = TRUE
)
```

For all model parameters, we used moderately informative logistic priors centered on zero with a scale of 1/2. Parameters were estimated with four independent MCMC chains retaining 10000 samples for each chain after 2000 warm-up samples.

```{r Priors}
sat_priors <- prior("logistic(0,1)", class = b)
theoretical_priors <- prior("normal(0,1)", class = b, nlpar = Baseline) +
  prior("normal(0,1)", class = b, nlpar = ActCue) +
  prior("normal(0,1)", class = b, nlpar = filterSpeed) +
  prior("normal(0,1)", class = b, nlpar = bindingAct)
theoretical_priors_reduced <- prior("normal(0,1)", class = b, nlpar = Baseline) +
  prior("normal(0,1)", class = b, nlpar = ActCue) +
  prior("constant(0)", class = b, nlpar = filterSpeed) +
  prior("normal(0,1)", class = b, nlpar = bindingAct)
```

```{r sampling_settings}
nChains <- 4
warmup_samples <- 2000
postwarmup_samples <- 10000
```

# Results

## Descriptive Statistics

```{r TableDesc}
#| label: tbl-descriptives
#| tab-cap: "Desciptive statistiscs for the proportion correct in the different experimental conditions and each CTI condition."
table_data <- agg_data %>% 
  group_by(Block, CTI) %>% 
  summarise(Mean = mean(correct/nTrials),
            SD = sd(correct/nTrials),
            Min = min(correct/nTrials),
            Max = max(correct/nTrials),
            .groups = "drop")
table_data[,3:6] <- round(table_data[,3:6],2)
knitr::kable(table_data)
```

The summary statistics for the Proportion of correct responses in the five different blocks for all CTI durations are given in @tbl-descriptives. @fig-descriptive displays the average performance across the different conditions and includes performance of each subject in each of the conditions.

```{r FigDesc, echo=FALSE}
desc_plot <- ggplot(data = agg_data,
                    aes(x = as.factor(CTI_num*100), y = correct/nTrials, color = as.factor(Block), fill = as.factor(Block), 
                        group = as.factor(Block), shape = as.factor(SaccadeFromCue))) +
  facet_grid(inhibition ~ binding, labeller = label_both) +
  ggplot2::geom_jitter(position = ggplot2::position_jitterdodge(jitter.width = jitter_width, dodge.width = plot_dodge),
                       alpha = point_alpha) +
  stat_summary(position = position_dodge(plot_dodge), fun.data = mean_se) +
  ggplot2::stat_summary(geom = "line", fun = "mean", position = ggplot2::position_dodge(plot_dodge)) +
  geom_hline(yintercept = 0.33, color = "red", linetype = "dashed") +
  labs(x = "Cue-Target Interval",
       y = "Proportion Correct",
       color = "Block", fill = "Block",
       shape = "Pos Cue = Target",
       title = "Descriptive Plot") +
  coord_cartesian(ylim = c(0,1))
ggsave(filename = "E5_Descriptives.jpg",desc_plot, dpi = 300, width = 7, height = 6)
```

![Average performance in the different experimental blocks for different CTI durations.](E5_Descriptives.jpg){#fig-descriptive}

## GLM: Accuracy

```{r FitModel}
fit_E5_sat <- brms::brm(model_sat,
                        data = agg_data,
                        family = model_family,
                        backend = "cmdstanr",
                        chains = nChains,
                        iter = warmup_samples + postwarmup_samples, 
                        warmup = warmup_samples,
                        prior = sat_priors,
                        save_pars = save_pars(all = T),
                        sample_prior = T,
                        file = "fit_Exp5_sat",
                        file_refit = "on_change")

fit_E5_th_full <- brms::brm(model_th_full,
                            data = agg_data,
                            family = model_family,
                            backend = "cmdstanr",
                            chains = nChains,
                            iter = warmup_samples + postwarmup_samples, 
                            warmup = warmup_samples,
                            prior = theoretical_priors,
                            save_pars = save_pars(all = T),
                            sample_prior = T,
                            file = "fit_Exp5_th_full",
                            file_refit = "on_change")

fit_E5_th_full_prior <- brms::brm(model_th_full,
                                  data = agg_data,
                                  family = model_family,
                                  backend = "cmdstanr",
                                  chains = nChains,
                                  iter = warmup_samples + postwarmup_samples, 
                                  warmup = warmup_samples,
                                  prior = theoretical_priors,
                                  save_pars = save_pars(all = T),
                                  sample_prior = "only",
                                  file = "fit_Exp5_th_full_priors",
                                  file_refit = "on_change")


# Test if parameters differ from zero
bf_pars <- bayestestR::bayesfactor_parameters(fit_E5_th_full,
                                              prior = fit_E5_th_full_prior)

# compute Bayes Factor for setting filter to zero
if (!file.exists("bridge_marginalLL_Exp5.rds")) {
  fit_E5_th_noBaseSD <- brms::brm(model_th_noBaseSD,
                                  data = agg_data,
                                  family = model_family,
                                  backend = "cmdstanr",
                                  chains = nChains,
                                  iter = warmup_samples + postwarmup_samples, 
                                  warmup = warmup_samples,
                                  prior = theoretical_priors,
                                  save_pars = save_pars(all = T),
                                  sample_prior = T,
                                  file = "fit_Exp5_th_noBaseSD",
                                  file_refit = "on_change")
  
  fit_E5_th_noSfCSD <- brms::brm(model_th_noSfCSD,
                                 data = agg_data,
                                 family = model_family,
                                 backend = "cmdstanr",
                                 chains = nChains,
                                 iter = warmup_samples + postwarmup_samples, 
                                 warmup = warmup_samples,
                                 prior = theoretical_priors,
                                 save_pars = save_pars(all = T),
                                 sample_prior = T,
                                 file = "fit_Exp5_th_noSfCSD",
                                 file_refit = "on_change")
  
  fit_E5_th_noSfFSD <- brms::brm(model_th_noSfFSD,
                                 data = agg_data,
                                 family = model_family,
                                 backend = "cmdstanr",
                                 chains = nChains,
                                 iter = warmup_samples + postwarmup_samples, 
                                 warmup = warmup_samples,
                                 prior = theoretical_priors,
                                 save_pars = save_pars(all = T),
                                 sample_prior = T,
                                 file = "fit_Exp5_th_noSfFSD",
                                 file_refit = "on_change")
  
  fit_E5_th_noAcSD <- brms::brm(model_th_noAcSD,
                                data = agg_data,
                                family = model_family,
                                backend = "cmdstanr",
                                chains = nChains,
                                iter = warmup_samples + postwarmup_samples, 
                                warmup = warmup_samples,
                                prior = theoretical_priors,
                                save_pars = save_pars(all = T),
                                sample_prior = T,
                                file = "fit_Exp5_th_noAcSD",
                                file_refit = "on_change")
  
  fit_E5_th_noFSD <- brms::brm(model_th_noFSD,
                               data = agg_data,
                               family = model_family,
                               backend = "cmdstanr",
                               chains = nChains,
                               iter = warmup_samples + postwarmup_samples, 
                               warmup = warmup_samples,
                               prior = theoretical_priors,
                               save_pars = save_pars(all = T),
                               sample_prior = T,
                               file = "fit_Exp5_th_noFSD",
                               file_refit = "on_change")
  
  fit_E5_th_noBindSD <- brms::brm(model_th_noBindSD,
                                  data = agg_data,
                                  family = model_family,
                                  backend = "cmdstanr",
                                  chains = nChains,
                                  iter = warmup_samples + postwarmup_samples, 
                                  warmup = warmup_samples,
                                  prior = theoretical_priors,
                                  save_pars = save_pars(all = T),
                                  sample_prior = T,
                                  file = "fit_Exp5_th_noBindSD",
                                  file_refit = "on_change")
  
  fit_E5_th_reduced <- brms::brm(model_th_reduced,
                                 data = agg_data,
                                 family = model_family,
                                 backend = "cmdstanr",
                                 chains = nChains,
                                 iter = warmup_samples + postwarmup_samples, 
                                 warmup = warmup_samples,
                                 prior = theoretical_priors_reduced,
                                 save_pars = save_pars(all = T),
                                 sample_prior = T,
                                 file = "fit_Exp5_th_reduced",
                                 file_refit = "on_change")
  
  bridge_full <- bridge_sampler(fit_E5_th_full, cores = 4, repetitions = 10)
  bridge_reduced <- bridge_sampler(fit_E5_th_reduced, cores = 4, repetitions = 10)
  bridge_noBaseSD <- bridge_sampler(fit_E5_th_noBaseSD, cores = 4, repetitions = 10)
  bridge_noSfCSD<- bridge_sampler(fit_E5_th_noSfCSD, cores = 4, repetitions = 10)
  bridge_noSfFSD <- bridge_sampler(fit_E5_th_noSfFSD, cores = 4, repetitions = 10)
  bridge_noAcSD <- bridge_sampler(fit_E5_th_noAcSD, cores = 4, repetitions = 10)
  bridge_noFSD <- bridge_sampler(fit_E5_th_noFSD, cores = 4, repetitions = 10)
  bridge_noBindSD <- bridge_sampler(fit_E5_th_noBindSD, cores = 4, repetitions = 10)
  
  marginalLL <- list(full = bridge_full,
                     reduced = bridge_reduced,
                     noBaseSD = bridge_noBaseSD,
                     noSfCSD = bridge_noSfCSD,
                     noSfFSD = bridge_noSfFSD,
                     noAcSD = bridge_noAcSD,
                     noFSD = bridge_noFSD,
                     noBindSD = bridge_noBindSD)
  saveRDS(marginalLL, "bridge_marginalLL_Exp5.rds")
} else {
  marginalLL <- readRDS("bridge_marginalLL_Exp5.rds")
}

# test if there is evidence for filtering
bf_filter <- bayes_factor(marginalLL$full, marginalLL$reduced)

# extract fixed effect for theoretical model
fixFX <- round(fixef(fit_E5_th_full),2)

newdata <- expand.grid(
  ID = unique(agg_data$ID),
  nTrials = 1,
  CTI_num = unique(agg_data$CTI_num),
  Block = unique(agg_data$Block)
)

newdata2 <- expand.grid(
  ID = unique(agg_data$ID),
  nTrials = 1,
  CTI_num = unique(agg_data$CTI_num),
  binding = unique(agg_data$binding),
  inhibition = unique(agg_data$inhibition),
  SaccadeFromCue = unique(agg_data$SaccadeFromCue),
  SaccadeFromFixation = unique(agg_data$SaccadeFromFixation)
) %>% 
  left_join(Block2Conds) %>% 
  filter(!is.na(Block))

tidy_pred_sat <- fit_E5_sat %>% 
  tidybayes::epred_draws(newdata = newdata) %>% 
  group_by(ID, CTI_num, Block) %>% 
  summarise(predValue = mean(.epred)) %>% 
  left_join(Block2Conds) %>% 
  filter(!is.na(Block))

pp_plot_sat <- ggplot(data = tidy_pred_sat,
                      aes(x = as.factor(CTI_num), y = predValue, color = as.factor(Block), fill = as.factor(Block), 
                          group = as.factor(Block), shape = as.factor(SaccadeFromCue))) +
  facet_grid(inhibition ~ binding, labeller = label_both) +
  ggplot2::geom_jitter(position = ggplot2::position_jitterdodge(jitter.width = jitter_width, dodge.width = plot_dodge),
                       alpha = point_alpha) +
  stat_summary(position = position_dodge(plot_dodge), fun.data = mean_se) +
  ggplot2::stat_summary(geom = "line", fun = "mean", position = ggplot2::position_dodge(plot_dodge)) +
  stat_summary(geom = "point", fun = mean, position = position_dodge(plot_dodge),
               data = agg_data, color = "black", shape = "cross",
               aes(x = as.factor(CTI_num), y = correct/nTrials)) +
  geom_hline(yintercept = 0.33, color = "red", linetype = "dashed") +
  labs(x = "Cue-Target Interval",
       y = "Proportion Correct",
       color = "Block", fill = "Block",
       shape = "Pos Cue = Target",
       title = "Posterior Predictives (sat)") +
  coord_cartesian(ylim = c(0,1))
ggsave(filename = "PostPredictives_sat_E5.jpg",pp_plot_sat, dpi = 300, width = 7, height = 6)

tidy_pred_theoretical <- fit_E5_th_full %>% 
  tidybayes::epred_draws(newdata = newdata2) %>% 
  group_by(ID, CTI_num, binding, inhibition, SaccadeFromCue, SaccadeFromFixation) %>% 
  summarise(predValue = mean(.epred)) %>% 
  left_join(Block2Conds) %>% 
  filter(!is.na(Block))

pp_plot_theoretical <- ggplot(data = tidy_pred_theoretical,
                              aes(x = as.factor(CTI_num), y = predValue, color = as.factor(Block), fill = as.factor(Block), 
                                  group = as.factor(Block), shape = as.factor(SaccadeFromCue))) +
  facet_grid(inhibition ~ binding, labeller = label_both) +
  ggplot2::geom_jitter(position = ggplot2::position_jitterdodge(jitter.width = jitter_width, dodge.width = plot_dodge),
                       alpha = point_alpha) +
  ggplot2::stat_summary(geom = "line", fun = "mean", position = ggplot2::position_dodge(plot_dodge)) +
  stat_summary(position = position_dodge(plot_dodge), fun.data = mean_se) +
  stat_summary(geom = "point", fun = mean, position = position_dodge(plot_dodge),
               data = agg_data, color = "black", shape = "cross",
               aes(x = as.factor(CTI_num), y = correct/nTrials)) +
  geom_hline(yintercept = 0.33, color = "red", linetype = "dashed") +
  labs(x = "Cue-Target Interval (in 1/100 ms)",
       y = "Proportion Correct",
       color = "Block", fill = "Block",
       shape = "Pos Cue = Target",
       title = "Posterior Predictives (Theoretical)") +
  coord_cartesian(ylim = c(0,1))
ggsave(filename = "PostPredictives_Theoretical_E5.jpg",pp_plot_theoretical, dpi = 300, width = 7, height = 6)
gc()
```

### Experimental Effects

![Posterior predictives of the average proportion correct as a function of CTI duration. The black crosses indicate the observed average proportion correct based on the data.](PostPredictives_Theoretical_E5.jpg){#fig-predictive}

@fig-predictive shows the posterior predictive estimates from the Bayesian GLM for the different experimental blocks and the changes in performance across the different CTI levels on the proportion correct scale. The theoretical model fits adequately to the observed data, as indicated by the black crosses in the plot.

First, we evaluated if there was evidence for the different theoretical assumed processes contributing to performance in the manual Anti-Saccade task. The results indicated that there was credible automatic activation of cues, $b_{Acue} = `r fixFX["ActCue_Intercept","Estimate"]`$, 95% CI = $[`r fixFX["ActCue_Intercept","Q2.5"]`;`r fixFX["ActCue_Intercept","Q97.5"]`]$, $BF_{10} =$ `r printnum(exp(bf_pars[which(bf_pars[,"Parameter"] == "b_ActCue_Intercept"),"log_BF"]), format = "g")`, which weakened with longer CTI duration, $b_{filter} = `r round(exp(fixFX["filterSpeed_Intercept","Estimate"]),2)`$, 95% CI = $[`r exp(fixFX["filterSpeed_Intercept","Q2.5"])`;`r exp(fixFX["filterSpeed_Intercept","Q97.5"])`]$, $BF_{10} =$ `r printnum( bf_filter[["bf_median_based"]], format = "g")`. Likewise, an informative association of the cue to the location of the target location improved performance with longer CTI duration, $b_{binding} = `r fixFX["bindingAct_Intercept","Estimate"]`$, 95% CI = $[`r fixFX["bindingAct_Intercept","Q2.5"]`;`r fixFX["bindingAct_Intercept","Q97.5"]`]$, $BF_{10} =$ `r printnum(exp(bf_pars[which(bf_pars[,"Parameter"] == "b_bindingAct_Intercept"),"log_BF"]), format = "g")`. In addition, both having to perform a saccade away from fixation, $b_{SfF} = `r fixFX["Baseline_SaccadeFromFixation","Estimate"]`$, 95% CI = $[`r fixFX["Baseline_SaccadeFromFixation","Q2.5"]`;`r fixFX["Baseline_SaccadeFromFixation","Q97.5"]`]$, $BF_{10} =$ `r printnum(exp(bf_pars[which(bf_pars[,"Parameter"] == "b_Baseline_SaccadeFromFixation"),"log_BF"]), format = "g")`, and a saccade away from the cue, $b_{SfC} = `r fixFX["Baseline_SaccadeFromCue","Estimate"]`$, 95% CI = $[`r fixFX["Baseline_SaccadeFromCue","Q2.5"]`;`r fixFX["Baseline_SaccadeFromCue","Q97.5"]`]$, $BF_{10} =$ `r printnum(exp(bf_pars[which(bf_pars[,"Parameter"] == "b_Baseline_SaccadeFromCue"),"log_BF"]), format = "g")`, resulted in worse performance. A summary of parameter estimates is displayed in @tbl-parameters.

```{r ParTable}
#| label: tbl-parameters
#| tab-cap: "Overview of parameter estimates"
randFX <- ranef(fit_E5_th_full)$ID
rownames(fixFX) <- stringr::str_remove(rownames(fixFX), "_Intercept")
fixFX["filterSpeed",]<- exp(fixFX["filterSpeed",])
apa_table(fixFX[,c("Estimate","Q2.5","Q97.5")])
```

### Individual Differences

```{r}
#| label: tbl-bfSD
#| tab-cap: "Bayes Factors in favor of individual differences in the processes seperated."
# test if there is evidence for individual differences in the different processes
bf_noBaseSD <- bayes_factor(marginalLL$full, marginalLL$noBaseSD)
bf_noSfFSD <- bayes_factor(marginalLL$full, marginalLL$noSfFSD)
bf_noSfCSD <- bayes_factor(marginalLL$full, marginalLL$noSfCSD)
bf_noAcSD <- bayes_factor(marginalLL$full, marginalLL$noAcSD)
bf_noFSD <- bayes_factor(marginalLL$full, marginalLL$noFSD)
bf_noBindSD <- bayes_factor(marginalLL$full, marginalLL$noBindSD)

df_bf_SD <- data.frame(
  process = c("Baseline","Saccade from Fixation", "Saccade From Cue", "Act: Cue", "Filtering", "Binding"),
  median_bf = c(bf_noBaseSD$bf_median_based, bf_noSfFSD$bf_median_based, bf_noSfCSD$bf_median_based, bf_noAcSD$bf_median_based,
                bf_noFSD$bf_median_based, bf_noBindSD$bf_median_based),
  min_bf = c(min(bf_noBaseSD$bf), min(bf_noSfFSD$bf), min(bf_noSfCSD$bf), min(bf_noAcSD$bf),
             min(bf_noFSD$bf), min(bf_noBindSD$bf)),
  max_bf = c(max(bf_noBaseSD$bf), max(bf_noSfFSD$bf), max(bf_noSfCSD$bf), max(bf_noAcSD$bf),
             max(bf_noFSD$bf), max(bf_noBindSD$bf))
)
knitr::kable(df_bf_SD)
```

As the manual Anti-Saccade task is commonly used in individual differences research to measure how people differ in their ability to control attention and how this is related to other cognitive abilities, we also tested if there are credible individual differences in the processes we dissociated in our model. We did so by selectively fixing the random effect of one of the processes to zero and test if this model was favored over a model freely estimating the random effect. These analyses indicated that there was credible evidence for individual differences in all processes separated in the model (see @tbl-bfSD).

```{r}
SD_hypothesis <- c(
  BaseVSfF = "Baseline_Intercept = Baseline_SaccadeFromFixation",
  BaseVSfC = "Baseline_Intercept = Baseline_SaccadeFromCue",
  BaseVAc = "Baseline_Intercept = ActCue_Intercept",
  BaseVBind = "Baseline_Intercept = bindingAct_Intercept",
  SfFVSfC = "Baseline_SaccadeFromFixation = Baseline_SaccadeFromCue",
  SfFVAc = "Baseline_SaccadeFromFixation = ActCue_Intercept",
  SfFVBind = "Baseline_SaccadeFromFixation = bindingAct_Intercept",
  SfCVAc = "Baseline_SaccadeFromCue = ActCue_Intercept",
  SfCVBind = "Baseline_SaccadeFromCue = bindingAct_Intercept",
  AcVBind = "ActCue_Intercept = bindingAct_Intercept"
)

hypSD <- hypothesis(fit_E5_th_full,
                    SD_hypothesis,
                    class = "sd", group = "ID")
```

We also estimated the correlations between all random effects. @tbl-correlations shows the estimated standard deviations of all random effects and the correlations among them. Generally, correlations between random effects were small, most $|r_s| < .30$, except for the correlation between the Intercept of Baseline performance and the cost of perforg a saccade away from the fixation, $r = -.59$, indicating that people that were good at discriminating the target letters overall exhibited larger cost for performing a saccade away from fixation. However, the generally small correlations indicate that our theoretical model is able to isolate different cognitive processes underlying performance in the manual Anti-Saccade tasks.

```{r CorrTable}
#| label: tbl-correlations
#| tab-cap: "Correlations between random effects. Values on the diagonal represent the posterior estimates of the standard deviation of each random effect."
corr_est <- VarCorr(fit_E5_th_full)$ID

cormat <- matrix(NA, nrow = nrow(fixFX), ncol = nrow(fixFX))

for (i in 1:dim(corr_est$cor)[3]){
  cormat[i,] <- corr_est$cor[,"Estimate",i]
}

rownames(cormat) <- stringr::str_remove(dimnames(corr_est$cor)[[3]],"_Intercept")
colnames(cormat) <- stringr::str_remove(dimnames(corr_est$cor)[[3]],"_Intercept")
diag(cormat) <- corr_est$sd[,"Estimate"]
cormat <- round(cormat,2)
cormat[upper.tri(cormat)] <- ""
knitr::kable(cormat)
```
