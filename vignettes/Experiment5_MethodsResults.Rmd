---
title: "Experiment5_MethodsResults"
output: bookdown::html_document2
pkgdown:
  as_is: true
---

```{r include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
pacman::p_load(AntiSaccade, papaja, brms, dplyr, ggplot2, here, lavaan)
options(mc.cores = parallel::detectCores())
```

# Methods
```{r load_data, include=FALSE}
data <- RawData_Exp5
nSub_total <- length(unique(data$ID))
data$CTI_num <- (data$CTI)/100
data$CTI <- as.factor(data$CTI)
data$RTms <- data$RTms + 150

levels(data$Block) <- stringr::str_replace_all(levels(data$Block), "[:digit:]", "")

inhib_blocks <- c("Anti","Random")
bind_blocks <- c("Pro","Anti","Colour")
SaccadeFromCue <- c("Anti","Random","Central")
SaccadeFromFixation <- c("Pro","Anti","Random","Central")

Block2Conds <- data.frame(
  Block = unique(data$Block)
)

data$inhibition <- ifelse(data$Block %in% inhib_blocks,1,0)
data$binding <- ifelse(data$Block %in% bind_blocks,1,0)
data$SaccadeFromCue <- ifelse(data$Block %in% SaccadeFromCue,1,0)
data$SaccadeFromFixation <- ifelse(data$Block %in% SaccadeFromFixation,1,0)

Block2Conds$inhibition <- ifelse(Block2Conds$Block %in% inhib_blocks,1,0)
Block2Conds$binding <- ifelse(Block2Conds$Block %in% bind_blocks,1,0)
Block2Conds$SaccadeFromCue <- ifelse(Block2Conds$Block %in% SaccadeFromCue,1,0)
Block2Conds$SaccadeFromFixation <- ifelse(Block2Conds$Block %in% SaccadeFromFixation,1,0)

outlier_data <- data %>% 
  group_by(ID, Block, CTI) %>% 
  summarise(meanPC = mean(correct),
            nTrials = n(),
            .groups = "drop") %>% 
  group_by(Block,CTI) %>% 
  mutate(
    meanPC_logit = logit_scaled(meanPC - (0.5/nTrials)),
    zPC_logit = (meanPC_logit - mean(meanPC_logit))/sd(meanPC_logit))
outlier_IDs2 <- unique(outlier_data$ID[which(outlier_data$meanPC <= qbinom(p = .95, size = outlier_data$nTrials, prob = 1/3)/outlier_data$nTrials)])
outlier_IDs <- unique(outlier_data$ID[which(outlier_data$zPC_logit <= qnorm(p = .01))])

data <- data %>% 
  filter(!ID %in% outlier_IDs)
nSub <- length(unique(data$ID))

# aggregate data for binomial models
agg_data <- data %>%
  dplyr::group_by(ID, Block, SaccadeFromCue, SaccadeFromFixation, inhibition, binding, CTI, CTI_num) %>%
  dplyr::summarise(
    correct = sum(correct),
    nTrials = dplyr::n(),
    .groups = "drop"
  )
```

## Participants

We recruited `r papaja::printnum(nSub_total)` participants via Prolific. Participants were required to be 18 to 40 years old, speak English as their first language, and have an approval rate of at least 85% when participating in studies on Prolific.

## Design

This study was designed to isolate different processes contributing to performance in the manual anti saccade task. For this, we adapted previous versions of the manual anti-saccade and increased the peripheral locations the target stimulus could appear in from 2 (left and right) to 4 (left, right, top, and bottom). This enabled to introduce new experimental blocks in addition to the traditional Pro- and Anti-Saccade Blocks. Specifically, in this experiment, we included 3 additional blocks: a No-Saccade Block in which both the cue and the target appeared in the center of the screen, a Random Saccade Block in which the target could appear in any of the non-cued location, and a Central-Saccade Block in which the cue appeared in the center and the target could appear in any of the four peripheral locations.  For an illustration of the manipulation implemented in these experimental blocks see Figure \@ref(fig:figCond).

(ref:desc_cond) Illustration of the different experimental blocks in the experiment. 

(ref:trial-type) The top row exemplifies one of the locations the cue could appear in, and the bottom row highlights in which locations (highlighted in dark red) the target could appear in.

```{r figCond, echo=FALSE, fig.align='center', out.width="80%", fig.cap = paste("(ref:desc_cond)", "(ref:trial-type)")}
knitr::include_graphics(path = "Conditions_Exp5.png")
```

In addition, we also included requirements to perform saccade away from Fixation or from the Cue to detect the target letter. The idea behind this was to include costs that occur because attention is partly guided by the transient onset signal of the cue. We aimed to separate these more exogenous processes of guiding attention, from the endogenous processes that are supposedly reling on attention control. An overview, of which processes were required in the different experimental blocks is shown in @tbl:Blocks2Procs

```{r Blocks2Procs}
Table_Blocks2Procs <- Block2Conds %>% 
  mutate(SensoryDisc = 1) %>% 
  select(Block, SensoryDisc, inhibition, binding, SaccadeFromFixation, SaccadeFromCue)

Table_Blocks2Procs[,2:6] <- ifelse(Table_Blocks2Procs[,2:6] == 1, "yes","no")
Table_Blocks2Procs <- Table_Blocks2Procs[c(2,3,1,4,5),]
colnames(Table_Blocks2Procs) <- c("Block", "Sensory Disc.", "Inhibition", "Binding", "Saccade from Fixation", "Saccade from Cue")
knitr::kable(Table_Blocks2Procs)
```

The idea underlying these different blocks is to systematically vary if participants need to inhibit automatic saccades towards the cue, and if the location the cue appears in is informative with respect to the target location. Thus, as already discussed in the introduction they require different processes that might be related to performance in the manual anti-saccade task. In detail, the No-Saccade block only requires to quickly discriminate between the target letters without any demands on controlling saccades and moving the eyes. The Pro-Saccade block adds the demands of performing a saccade to the cued locations. This could happen automatically or controlled. But it does not require to inhibit the automatic saccade. The Anti-Saccade block requires subjects to move their gaze to the opposite location of where the cue appeared. This requires inhibiting the automatic saccade elicited by the transient onset signal of the cue, and performing a controlled saccade to the opposite location. The Random saccade block require to inhibit the automatic saccade towards the cue, but does not allow for a controlled saccade towards the target location as it can not be inferred from the location the cue appeared in. Finally, the Central block neither requires to inhibit an automatic saccade, as the cue appears in the center, but also does not allow for a controlled saccade as the cue is not informative for the target location. But unlike in the No-Saccade condition the target does appear in one of the peripheral locations, thus only the transient onset signal of the target will draw attention towards the target location.

In addition, we varied the Cue-Traget Innterval in three levels: 50, 200, 400ms to evaluate if longer time to inhibit automatic saccades towards the cued-location when required and use the location of the cue to perform a controlled saccade when possible improves performance.

## Trial Procedure

Each trial started with a fixation cross that was presented for a variable fixation duration from 200 to 1400 ms in steps of 400 ms. After the fixation cross the cue was presented either in one of the four peripheral locations or in the center (only for the No-Saccade Block). The cue, a "=" appeared for 100 ms, then offset for 50 ms, and appeared again for 100 ms. This flickering was done to increase the transient signal of the cue and maximize the elicitation of automatic saccades. The screen then was blank for a CTI of 50, 200, or 400ms. After that the target letter - either a "P", "B", or "R" - appeared for 100ms in one of the peripheral locations or in the center according to the specified rules for the current block. The target letter was then backward masked with an "H" appearing for 50ms and and "8" remaining on screen until participants responded which letter they detected by pressing "P", "B", or "R" on the keyboard. For an illustration of the trial procedured see Figure \@ref(fig:figTrial)

```{r figTrial, echo=FALSE, fig.align='center', out.width="80%", fig.cap = paste("(ref:description)", "(ref:trial-type)")}
knitr::include_graphics(path = "Figure_SaccadeTask2.png")
```

For each trial, we recorded the response given as well as the response time as the time between onset of the target stimulus until the response. In each block we ran 144 trials, so that each of the three target letters, appeared once in each of the four peripheral locations with each of the four fixation durations and three CTIs.

## Data Analysis

```{r include=FALSE}
n_full <- nrow(data)
data <- data %>% filter(RTms > 150, RTms < 5000)
n_filter <- nrow(data)



prop_filter <- (1 - n_filter/n_full) * 100
```

Prior to data analysis we removed trials with reaction times shorter than 150 ms and longer than 5000ms. This resulted in discarding `r papaja::printnum(prop_filter)`% of data.

We analyzed the number of correct responses with a Bayesian Generalized Linear Model assuming the number of correct responses follows a binomial distribution. We used a logit link function, thus estimating the linear model on the logit-scale. The model was estimated using the R package `brms`.

```{r model_family}
model_family <- brmsfamily("binomial", link = "logit")
```

To incorporate the theoretical assumptions outlined in the introduction, we specified that:

1. conditions requiring the inhibition of the cued location (i.e. the Anti- and Random-Saccade block) would be lower in performance due to automatic activation from the cue. The lower this activation, the better a person is to avoid attention being captured by the cue. In theoretical terms differences between individuals in this activation from the cue represent pro-active control.
2. automatic activation of the cue could be filtered out over time. This was implemented with an exponential decay function, reflecting that a certain proportion of cue activation gets filtered over time. The higher this filtering, the better a person is to re-actively control attention and reduce activation from the cue over time.
3. informative associations of cues to the target locations (in the Pro- and Anti-Saccade Block) could be used to improve performance over time. This binding activation reflects a persons ability to use the association of the cued location to the target location to endogenously direct attention towards the cued location and improve the performance. We assumed that this process unfolds linearly with longer CTI duration.

For an illustration of these theoretically informed processes, see Figure \@ref(fig:Fig_TheoreticalModel). Specifically, the black line represents baseline performance independent of the above mentioned processes, that is performance in the Random Saccade Block. The differences at time 0 between the black and the red line represents the automatic activation of the cue, that declines exponentially towards the black line with time. The green line represents the use of binding information over time that improves performance with longer CTI duration. As this model was implemented on the logit-scale, the increases in perofrance on the probability scale are non-linear for binding benefits as a result of the logit link function.

```{r Fig_TheoreticalModel, echo=FALSE}
expDecay <- function(x, ActCue, filterSpeed, Baseline, scale = "prob") {
  y <- Baseline - ActCue * exp(-filterSpeed*x)
  if(scale == "prob") {
    brms::inv_logit_scaled(y)
  } else {
    y
  }
}

linBinding <- function(x, bindingAct, Baseline, scale = "prob") {
  y <- Baseline + bindingAct * x
  if(scale == "prob") {
    brms::inv_logit_scaled(y)
  } else {
    y
  }
}

BasePerformance <- function(x, Baseline, scale = "prob") {
  y <- Baseline + x*0
  
  if(scale == "prob") {
    brms::inv_logit_scaled(y)
  } else {
    y
  }
}

ggplot() +
  xlim(0,4) +
  geom_function(fun = expDecay,
                args = list(Baseline = 1.43, ActCue = 0.62, filterSpeed = 0.5),
                color = "darkred")  +
  geom_function(fun = linBinding,
                args = list(Baseline = 1.43, bindingAct = 0.20),
                color = "darkgreen") +
  geom_function(fun = BasePerformance,
                args = list(Baseline = 1.43)) +
  labs(y = "Proportion Correct",
       x = "CTI duration",
       title = "Theoretical Model (Probability Scale)") +
  theme_bw() +
  theme(panel.grid.major.x  = element_blank(),
        panel.grid.minor.x = element_blank())

ggplot() +
  xlim(0,4) +
  geom_function(fun = expDecay,
                args = list(Baseline = 1.43, ActCue = 0.5, filterSpeed = 0.5, scale = "logit"),
                color = "darkred")  +
  geom_function(fun = linBinding,
                args = list(Baseline = 1.43, bindingAct = 0.2, scale = "logit"),
                color = "darkgreen") +
  geom_function(fun = BasePerformance,
                args = list(Baseline = 1.43, scale = "logit"),
                linetype = "dashed") +
  labs(y = "Proportion Correct",
       x = "CTI duration",
       title = "Theoretical Model (Logit Scale)") +
  theme_bw() +
  theme(panel.grid.major.x  = element_blank(),
        panel.grid.minor.x = element_blank())

```

In addition, we added additive effects on the Baseline performance that reflected if a condition required that a saccade needed to be made away from the fixation or from the cue. This reflects differences between the NoSaccade condition and the Central Saccade condition. These effects were independent from the other theoretically motivated effects.

```{r LinearModel}
saturated_model <- bf(correct | trials(nTrials) ~ 
                        # fixed effects
                        0 + Block + Block:CTI_num + 
                        # random effects
                        (0 + Block + Block:CTI_num | ID))

theoretical_model_full <- bf(correct | trials(nTrials) ~ Baseline - 
                               inhibition*(ActCue * exp(-exp(filterSpeed)*CTI_num)) + 
                               binding*(bindingAct*CTI_num),
                             Baseline ~ 1 + SaccadeFromCue + SaccadeFromFixation +
                               (1 + SaccadeFromCue + SaccadeFromFixation  |r| ID),
                             ActCue ~ 1 + (1 |r| ID),
                             filterSpeed ~ 1 + (1 |r| ID),
                             bindingAct ~ 1 + (1 |r| ID),
                             nl = TRUE
)

theoretical_model_reduced <- bf(correct | trials(nTrials) ~ Baseline - 
                                  inhibition*(ActCue) * exp(-filterSpeed*CTI_num)  + 
                                  binding*(bindingAct*CTI_num),
                                Baseline ~ 1 + SaccadeFromCue + SaccadeFromFixation +
                                  (1 + SaccadeFromCue + SaccadeFromFixation  |r| ID),
                                ActCue ~ 1 + (1 |r| ID),
                                filterSpeed ~ 1,
                                bindingAct ~ 1 + (1 |r| ID),
                                nl = TRUE
)
```

For all model parameters, we used moderately informative normal priors centered on zero with a scale of one. Parameters were estimated with four independent MCMC chains retaining 10000 samples for each chain after 2000 warmup samples.

```{r Priors}
saturated_priors <- prior("logistic(0,1)", class = b)
theoretical_priors <- prior("normal(0,1)", class = b, nlpar = Baseline) +
  prior("normal(0,1)", class = b, nlpar = ActCue) +
  prior("normal(0,1)", class = b, nlpar = filterSpeed) +
  prior("normal(0,1)", class = b, nlpar = bindingAct)
theoretical_priors_reduced <- prior("normal(0,1)", class = b, nlpar = Baseline) +
  prior("normal(0,1)", class = b, nlpar = ActCue) +
  prior("constant(0)", class = b, nlpar = filterSpeed) +
  prior("normal(0,1)", class = b, nlpar = bindingAct)
```

```{r sampling_settings}
nChains <- 4
warmup_samples <- 2000
postwarmup_samples <- 10000
```

# Results

## Descriptives

The summary statistics for the Proportion of correct responses in the five different blocks for all CTI duration are given in \@ref(tab:TableDesc). Figure \@ref(fig:FigDesc) displays the changes of performance across the different conditions and includes performance of each subject in each of the conditions.

```{r TableDesc, echo=FALSE, fig.align='center', out.width="80%"}
table_data <- agg_data %>% 
  group_by(Block, CTI) %>% 
  summarise(Mean = mean(correct/nTrials),
            SD = sd(correct/nTrials),
            Min = min(correct/nTrials),
            Max = max(correct/nTrials),
            .groups = "drop")

apa_table(table_data,
          caption = "Desciptive statistiscs for the proportion correct in all experimental conditions.",
          landscape = TRUE)
```


```{r FigDesc, echo=FALSE, fig.align='center', fig.height=4, fig.width=6, message=FALSE, warning=FALSE, fig.cap="Descriptive plots of the average performance and performance of each subject in each block across the different CTI durations"}
desc_plot <- ggplot(data = agg_data,
                    aes(x = as.factor(CTI_num*100), y = correct/nTrials, color = as.factor(Block), fill = as.factor(Block), 
                        group = as.factor(Block), shape = as.factor(SaccadeFromCue))) +
  facet_grid(inhibition ~ binding, labeller = label_both) +
  ggplot2::geom_jitter(position = ggplot2::position_jitterdodge(jitter.width = 1, dodge.width = 1),
                       alpha = 0.1) +
  stat_summary(position = position_dodge(1), fun.data = mean_se) +
  ggplot2::stat_summary(geom = "line", fun = "mean", position = ggplot2::position_dodge(1)) +
  geom_hline(yintercept = 0.33, color = "red", linetype = "dashed") +
  labs(x = "Cue-Target Interval",
       y = "Proportion Correct",
       color = "Block", fill = "Block",
       shape = "Pos Cue = Target",
       title = "Descriptive Plot") +
  coord_cartesian(ylim = c(0,1)) +
  theme_minimal()
ggsave(filename = "E5_Descriptives.jpg",desc_plot, dpi = 300, width = 7, height = 6)
desc_plot
```

## GLM: Accuracy

```{r FitModel, echo=FALSE, message=FALSE, warning=FALSE}
fit_E5_saturated <- brms::brm(saturated_model,
                              data = agg_data,
                              family = model_family,
                              backend = "cmdstanr",
                              chains = nChains,
                              iter = warmup_samples + postwarmup_samples, 
                              warmup = warmup_samples,
                              prior = saturated_priors,
                              save_pars = save_pars(all = T),
                              sample_prior = T,
                              file = "fit_Exp5_saturated",
                              file_refit = "on_change")

fit_E5_theoretical_full <- brms::brm(theoretical_model_full,
                                     data = agg_data,
                                     family = model_family,
                                     backend = "cmdstanr",
                                     chains = nChains,
                                     iter = warmup_samples + postwarmup_samples, 
                                     warmup = warmup_samples,
                                     prior = theoretical_priors,
                                     save_pars = save_pars(all = T),
                                     sample_prior = T,
                                     file = "fit_Exp5_theoretical_full",
                                     file_refit = "on_change")

fit_E5_theoretical_reduced <- brms::brm(theoretical_model_reduced,
                                        data = agg_data,
                                        family = model_family,
                                        backend = "cmdstanr",
                                        chains = nChains,
                                        iter = warmup_samples + postwarmup_samples, 
                                        warmup = warmup_samples,
                                        prior = theoretical_priors_reduced,
                                        save_pars = save_pars(all = T),
                                        sample_prior = T,
                                        file = "fit_Exp5_theoretical_reduced",
                                        file_refit = "on_change")

fit_E5_theoretical_full_prior <- brms::brm(theoretical_model_full,
                                       data = agg_data,
                                       family = model_family,
                                       backend = "cmdstanr",
                                       chains = nChains,
                                       iter = warmup_samples + postwarmup_samples, 
                                       warmup = warmup_samples,
                                       prior = theoretical_priors,
                                       save_pars = save_pars(all = T),
                                       sample_prior = "only",
                                       file = "fit_Exp5_theoretical_full_priors",
                                       file_refit = "on_change")

fit_E5_theoretical_reduced_prior <- brms::brm(theoretical_model_reduced,
                                       data = agg_data,
                                       family = model_family,
                                       backend = "cmdstanr",
                                       chains = nChains,
                                       iter = warmup_samples + postwarmup_samples, 
                                       warmup = warmup_samples,
                                       prior = theoretical_priors_reduced,
                                       save_pars = save_pars(all = T),
                                       sample_prior = "only",
                                       file = "fit_Exp5_theoretical_reduced_priors",
                                       file_refit = "on_change")

# Test if parameters differ from zero
bf_pars <- bayestestR::bayesfactor_parameters(fit_E5_theoretical_full,
                                               prior = fit_E5_theoretical_full_prior)

bridge_full <- bridge_sampler(fit_E5_theoretical_full, repetitions = 10)
bridge_reduced <- bridge_sampler(fit_E5_theoretical_reduced, repetitions = 10)

bf_filter <- bayes_factor(bridge_full, bridge_reduced)

# extract fixed effect for theoretical model
fixFX <- fixef(fit_E5_theoretical_full_prior)

newdata <- expand.grid(
  ID = unique(agg_data$ID),
  nTrials = 1,
  CTI_num = unique(agg_data$CTI_num),
  Block = unique(agg_data$Block)
)

newdata2 <- expand.grid(
  ID = unique(agg_data$ID),
  nTrials = 1,
  CTI_num = unique(agg_data$CTI_num),
  binding = unique(agg_data$binding),
  inhibition = unique(agg_data$inhibition),
  SaccadeFromCue = unique(agg_data$SaccadeFromCue),
  SaccadeFromFixation = unique(agg_data$SaccadeFromFixation)
) %>% 
  left_join(Block2Conds) %>% 
  filter(!is.na(Block))

tidy_pred_saturated <- fit_E5_saturated %>% 
  tidybayes::epred_draws(newdata = newdata) %>% 
  group_by(ID, CTI_num, Block) %>% 
  summarise(predValue = mean(.epred)) %>% 
  left_join(Block2Conds) %>% 
  filter(!is.na(Block))

pp_plot_saturated <- ggplot(data = tidy_pred_saturated,
                            aes(x = as.factor(CTI_num), y = predValue, color = as.factor(Block), fill = as.factor(Block), 
                                group = as.factor(Block), shape = as.factor(SaccadeFromCue))) +
  facet_grid(inhibition ~ binding, labeller = label_both) +
  ggplot2::geom_jitter(position = ggplot2::position_jitterdodge(jitter.width = 0.5, dodge.width = .5),
                       alpha = 0.1) +
  stat_summary(position = position_dodge(0.5), fun.data = mean_se) +
  ggplot2::stat_summary(geom = "line", fun = "mean", position = ggplot2::position_dodge(0.5)) +
  
  stat_summary(geom = "point", fun = mean, position = position_dodge(0.5),
               data = agg_data, color = "black", shape = "cross",
               aes(x = as.factor(CTI_num), y = correct/nTrials)) +
  geom_hline(yintercept = 0.33, color = "red", linetype = "dashed") +
  labs(x = "Cue-Target Interval",
       y = "Proportion Correct",
       color = "Block", fill = "Block",
       shape = "Pos Cue = Target",
       title = "Posterior Predictives (Saturated)") +
  coord_cartesian(ylim = c(0,1))
ggsave(filename = "PostPredictives_Saturated_E5.jpg",pp_plot_saturated, dpi = 300, width = 7, height = 6)

tidy_pred_theoretical <- fit_E5_theoretical_full %>% 
  tidybayes::epred_draws(newdata = newdata2) %>% 
  group_by(ID, CTI_num, binding, inhibition, SaccadeFromCue, SaccadeFromFixation) %>% 
  summarise(predValue = mean(.epred)) %>% 
  left_join(Block2Conds) %>% 
  filter(!is.na(Block))

pp_plot_theoretical <- ggplot(data = tidy_pred_theoretical,
                              aes(x = as.factor(CTI_num), y = predValue, color = as.factor(Block), fill = as.factor(Block), 
                                  group = as.factor(Block), shape = as.factor(SaccadeFromCue))) +
  facet_grid(inhibition ~ binding, labeller = label_both) +
  ggplot2::geom_jitter(position = ggplot2::position_jitterdodge(jitter.width = 0.5, dodge.width = .5),
                       alpha = 0.1) +
  ggplot2::stat_summary(geom = "line", fun = "mean", position = ggplot2::position_dodge(0.5)) +
  stat_summary(position = position_dodge(0.5), fun.data = mean_se) +
  stat_summary(geom = "point", fun = mean, position = position_dodge(0.5),
               data = agg_data, color = "black", shape = "cross",
               aes(x = as.factor(CTI_num), y = correct/nTrials)) +
  geom_hline(yintercept = 0.33, color = "red", linetype = "dashed") +
  labs(x = "Cue-Target Interval (in 1/100 ms)",
       y = "Proportion Correct",
       color = "Block", fill = "Block",
       shape = "Pos Cue = Target",
       title = "Posterior Predictives (Theoretical)") +
  coord_cartesian(ylim = c(0,1))
ggsave(filename = "PostPredictives_Theoretical_E5.jpg",pp_plot_theoretical, dpi = 300, width = 7, height = 6)
gc()
```

(ref:post-pred) Posterior predictive statistics of the average proportion correct as a function of CTI duration in the three experimental blocks.

```{r Fig_PostPred, echo=FALSE, fig.align='center', out.width="80%", fig.cap = paste("(ref:post-pred)")}
pp_plot_theoretical
```

Figure \@ref(fig:Fig_PostPred) shows the posterior predictive estimates from the Bayesian GLM for the different experimental blocks and the changes in performance across the different CTI levels on the proportion correct scale. 

First, we evaluated if there was evidence for the different theoretical assumed processes contributing to performance in the manual Anti-Saccade task. The results indicated that there was credible automatic activation of cues, $b_{CueAct} = `r `$, $BF_{10} = `r printnum(exp(bf_pars1$log_BF[which(bf_pars1$Parameter == "b_ActCue_Intercept")]), format = "g")`$, which weakened with longer CTI duration, $BF_{10} = `r printnum(exp(bf_pars1$log_BF[which(bf_pars1$Parameter == "b_filterSpeed_Intercept")]), format = "g")`$. Likewise, an informative association of the cue to the location of the target location improved performance with longer CTI duration, $BF_{10} = `r printnum(exp(bf_pars1$log_BF[which(bf_pars1$Parameter == "b_bindingAct_Intercept")]), format = "g")`$. In addition, both having to perform a saccade away from fixation, $BF_{10} = `r printnum(exp(bf_pars1$log_BF[which(bf_pars1$Parameter == "b_Baseline_SaccadeFromFixation")]), format = "g")`$, and a saccade away from the cue, $BF_{10} = `r printnum(exp(bf_pars1$log_BF[which(bf_pars1$Parameter == "b_Baseline_SaccadeFromCue")]), format = "g")`$, resulted in worse performance. A summary of parameter estimates is displayed in Table \@ref(tab:ParTable).

```{r ParTable, echo = F}
fixFX <- fixef(fit_E5_theoretical1)
randFX <- ranef(fit_E5_theoretical1)$ID
rownames(fixFX) <- stringr::str_remove(rownames(fixFX), "_Intercept")
apa_table(fixFX[,c("Estimate","Q2.5","Q97.5")])
```

```{r echo=FALSE}
corr_est <- VarCorr(fit_E5_theoretical1)$ID

cormat <- matrix(NA, nrow = nrow(fixFX), ncol = nrow(fixFX))

for(i in 1:dim(corr_est$cor)[3]){
  cormat[i,] <- corr_est$cor[,"Estimate",i]
}

rownames(cormat) <- stringr::str_remove(dimnames(corr_est$cor)[[3]],"_Intercept")
colnames(cormat) <- stringr::str_remove(dimnames(corr_est$cor)[[3]],"_Intercept")
diag(cormat) <- corr_est$sd[,"Estimate"]
apa_table(cormat)
```

