---
title: "Experiment5_MethodsResults"
output: bookdown::html_document2
vignette: >
%\VignetteIndexEntry{Experiment5_MethodsResults}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  pkgdown:
  as_is: true
---

```{r include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
pacman::p_load(AntiSaccade, papaja, brms, dplyr, ggplot2, here, lavaan)
options(mc.cores = parallel::detectCores())
```

# Methods
```{r load_data, include=FALSE}
data <- RawData_Exp5
nSub <- length(unique(data$ID))
data$CTI_num <- (data$CTI)/100
data$CTI <- as.factor(data$CTI)
data$RTms <- data$RTms + 150

inhib_blocks <- c("Anti","Random")
bind_blocks <- c("Pro","Anti","Colour")
CueTargetDiff_blocks <- c("Anti","Random","Central","Colour")

Block2Conds <- data.frame(
  Block = unique(data$Block)
)

data$inhibition <- ifelse(data$Block %in% inhib_blocks,1,0)
data$binding <- ifelse(data$Block %in% bind_blocks,1,0)
data$Pos_CueTarget_diff <- ifelse(data$Block %in% CueTargetDiff_blocks,1,0)

Block2Conds$inhibition <- ifelse(Block2Conds$Block %in% inhib_blocks,1,0)
Block2Conds$binding <- ifelse(Block2Conds$Block %in% bind_blocks,1,0)
Block2Conds$Pos_CueTarget_diff <- ifelse(Block2Conds$Block %in% CueTargetDiff_blocks,1,0)
```

## Participants

We recruited `r papaja::printnum(nSub)` participant via Prolific. Participants were required to be 18 to 40 years old, speak English as their first language, and have an approval rate of at least 85% when participating in studies on Prolific.

## Design

In this study, we examined individual differences in five different blocks of a saccade task. In addition to the traditional Pro- and Anti-Saccade Blocks, we included 3 additional blocks: a Random Saccade Block in which the target could appear in any of the non-cued location, a Central-Saccade Block in which the cue appeared in the center and the target could appear in any of the four peripheral locations, and a No-Saccade Block in which both the cue and the target appeared in the center of the screen. For an illustration of these different blocks see Figure \@ref(fig:figCond).

(ref:description) Illustration of the different blocks we ran in Experiment 5. 

(ref:trial-type) The top row exemplifies one of the locations the cue could appear in, and the bottom row highlights in which locations (highlighted in dark red) the target could appear in.

```{r figCond, echo=FALSE, fig.align='center', out.width="80%", fig.cap = paste("(ref:description)", "(ref:trial-type)")}
knitr::include_graphics(path = "Conditions_Exp5.png")
```

The idea underlying these different blocks is that they require different processes that might be related to performance in the manual anti-saccade task. The No-Saccade block isolated the ability to quickly discriminate between the target letters without any demands on controlling saccades and moving the eyes. The Pro-Saccade block adds the demands of performing a saccade to the cued locations. This could happen automatically or controlled. But it does not require to inhibit the automatic saccade. The Anti-Saccade block requires subjects to move their gaze to the opposite location of where the cue appeared. This requires inhibiting the automatic saccade elicited by the transient onset signal of the cue, and performing a controlled saccade to the opposite location. The Random saccade block require to inhibit the automatic saccade towards the cue, but does not allow for a controlled saccade towards the target location as it can not be inferred from the location the cue appeared in. Finally, the Central block neither requires to inhibit an automatic saccade, as the cue appears in the ceneter, but also does not allow for a controlled saccade as the cue is not informative for the target location. But unlike in the No-Saccade condition the target does appear in one of the peripheral locations.

Within each of the blocks, we additionally varied the Cue-Traget Inntervall in three levels: 50, 200, 400ms. The idea was to evaluate if longer time to inhibit the cue-location and potentially use the location of the cue to perform a controlled saccade, when possible improves performance. 

## Trial Procedure

Each trial started with a fixation cross that was presented for a variable fixation duration from 200 to 1400 ms in steps of 400 ms. After the fixation cross the cue was presented either in one of the four peripheral locations or in the center dependent on the Block conditions. The cue appeared for 100 ms, then offset for 50 ms, and appeared again for 100 ms. This flickering was done to increase the transient signal of the cue and maximize the elicitation of automatic saccades. The screen then was blank for the varying CTI durations, and after that the target appeared for 100ms in one of the peripheral locations or in the center dependent on the current block condition. The target was then backward masked with an "H" appearing for 50ms and and "8" remaining on screen until participants responded by pressing "P", "B", or "R" on the keyboard.

For each trial, we recorded the response given as well as the response time as the time between onset of the target stimulus until the response.

In each block we ran 144 trials. Thus, each of the three letters, appeared once in each of the four peripheral locations with each of the four fixation durations and three CTIs.

## Data Analysis

```{r include=FALSE}
n_full <- nrow(data)
data <- data %>% filter(RTms > 150, RTms < 10000)
n_filter <- nrow(data)

prop_filter <- (1 - n_filter/n_full) * 100
```

Prior to data analysis we removed trials with reaction times shorter than 50 ms and longer than 5000ms. This resulted in discarding `r papaja::printnum(prop_filter)`% of data.

We analyzed the number of correct responses with a Bayesian Generalized Linear Model assuming the number of correct responses to follow a binomial distribution. We used a logit link function, thus estimating the linear model on the logit-scale. The model was estimated using the R package `brms`.

```{r model_family}
model_family <- brmsfamily("binomial", link = "logit")
```

Specifically, we estimated the mean performance in each block at the shortest CTI duration as separate intercepts. We then included a linear CTI effect for each Block to estimate changes in performance as CTIs get longer. We included random effects for the intercepts and linear CTI effects in each Block without estimating the correlations between them:

```{r LinearModel}
saturated_model <- bf(correct | trials(nTrials) ~ 
                        # fixed effects
                        0 + Block + Block:CTI_num + 
                        # random effects
                        (0 + Block + Block:CTI_num | ID))

theoretical_model <- bf(correct | trials(nTrials) ~ 
                          AvgPerf - inhibition*(inhibInit * exp(-exp(inhibSlope)*CTI_num)),
                        AvgPerf ~ 1 + Pos_CueTarget_diff + binding:CTI_num +
                          (1 + Pos_CueTarget_diff + binding:CTI_num |r| ID),
                        inhibInit ~ 1 + (1 |r| ID),
                        inhibSlope ~ 1 + (1 |r|ID),
                        nl = TRUE
)
```

For all parameters, we used moderately informative normal priors centered on zero with a standard deviation on one.

```{r Priors}
saturated_priors <- prior("logistic(0,1)", class = b)
theoretical_priors <- prior("logistic(0,1)", class = b, nlpar = AvgPerf) +
  prior("logistic(0,1)", class = b, nlpar = inhibInit) +
  prior("normal(0,1)", class = b, nlpar = inhibSlope) 
```

We estimated parameter with four independent MCMC chains retaining 10000 samples for each chain after 2000 warmup samples:

```{r sampling_settings}
nChains <- 4
warmup_samples <- 2000
postwarmup_samples <- 10000
```

# Results

## Descriptives

```{r Agg_data, include=FALSE}
lin_model <- bf(correct | trials(nTrials) ~ 
                  0 + Block + Block:CTI_num + 
                  # random effects
                  (0 + Block + Block:CTI_num | ID))

agg_data <- data %>%
  dplyr::group_by(ID, Block, Pos_CueTarget_diff, inhibition, binding, CTI_num) %>%
  dplyr::summarise(
    correct = sum(correct),
    nTrials = dplyr::n(),
    .groups = "drop"
  )
```

```{r TableDesc, echo=FALSE, fig.align='center', out.width="80%"}
table_data <- agg_data %>% 
  group_by(Block, CTI_num) %>% 
  summarise(Mean = mean(correct/nTrials),
            SD = sd(correct/nTrials),
            Min = min(correct/nTrials),
            Max = max(correct/nTrials),
            .groups = "drop") %>% 
  mutate(CTI_num = as.factor(round(CTI_num * 100)))

names(table_data)[which(names(table_data) == "CTI_num")] <- "CTI"

apa_table(table_data,
          caption = "Desciptive statistiscs for the proportion correct in all experimental conditions.",
          landscape = TRUE)
```

The summary statistics for the Proportion of correct responses in the three different blocks for all CTI duration is given in \@ref(tab:TableDesc). Figure \@ref(fig:FigDesc) displays the changes of performance across the different conditions and includes performance of each subject in each of the conditions.

```{r FigDesc, echo=FALSE, fig.align='center', fig.height=4, fig.width=6, message=FALSE, warning=FALSE, fig.cap="Descriptive plots of the average performance and performance of each subject in each block across the different CTI durations"}
lin_mod <- bf(correct | trials(nTrials) ~ 0 + CTI:Block + (0 + CTI:Block || ID))
agg_data2 <- aggregate_data(lin_mod, data, family = binomial())
desc_plot <- plot_descriptives(agg_data2, lin_mod, family = binomial(), idVar = "ID")
desc_plot + ggplot2::labs(y = "Proportion Correct", x = "Experimental Block") +
  geom_hline(yintercept = 0.33, linetype = "dashed", color = "red")
```


## GLM: Accuracy

```{r FitModel, echo=FALSE}
fit_saturated <- brms::brm(saturated_model,
                           data = agg_data,
                           family = model_family,
                           backend = "cmdstanr",
                           chains = nChains,
                           iter = warmup_samples + postwarmup_samples, warmup = warmup_samples,
                           prior = saturated_priors,
                           save_pars = save_pars(all = T),
                           sample_prior = T,
                           file = "fit_Exp5_saturated",
                           file_refit = "on_change")

pp_check(fit_satureade, type = "dens_overlay_grouped", group = "Block", ndraws = 10)

fit_theoretical <- brms::brm(theoretical_model,
                             data = agg_data,
                             family = model_family,
                             backend = "cmdstanr",
                             chains = nChains,
                             iter = warmup_samples + postwarmup_samples, warmup = warmup_samples,
                             prior = theoretical_priors,
                             save_pars = save_pars(all = T),
                             sample_prior = T,
                             file = "fit_Exp5_theoretical",
                             file_refit = "on_change")

pp_check(fit_satureade, type = "dens_overlay_grouped", group = "Block", ndraws = 10)
```

(ref:post-pred) Posterior predictive statistics of the average proportion correct as a function of CTI duration in the three experimental blocks.

```{r PredEffects, echo=FALSE, message=FALSE, warning=FALSE, fig.cap="(ref:post-pred)", fig.align='center'}
FXplots <- conditional_effects(fit_binomial)
data_plot <- FXplots$`CTI_num:Block` %>% 
  mutate(CTI = CTI_num*100 + 50)

ggplot(data = data_plot,
       aes(x = CTI, y = estimate__, ymin = lower__, ymax = upper__, group = Block, fill = Block)) +
  geom_line(aes(color = Block)) +
  geom_ribbon(alpha = 0.3) +
  labs(x = "Cue-Target Intervall", y = "Posterior: Proportion Correct") +
  theme_bw() +
  theme(panel.grid.minor.x = element_blank(),
        panel.grid.major.x = element_blank())
```



```{r echo=FALSE}
hyp_fit <- c(NoSaccade_Pro = "BlockNoSaccade = BlockPro",
             NoSaccade_Anti = "BlockNoSaccade = BlockAnti",
             NoSaccade_Ran = "BlockNoSaccade = BlockRandom",
             NoSaccade_Cen = "BlockNoSaccade = BlockCentral4",
             Pro_Anti = "BlockPro = BlockAnti",
             Pro_Ran = "BlockPro = BlockRandom",
             Pro_Cen = "BlockPro = BlockCentral4",
             Anti_Ran = "BlockAnti = BlockRandom",
             Anti_Cen = "BlockAnti = BlockCentral4",
             Ran_Cen = "BlockRandom = BlockCentral4",
             CTI_No = "BlockNoSaccade:CTI_num = 0",
             CTI_Pro = "BlockPro:CTI_num = 0",
             CTI_Anti = "BlockAnti:CTI_num = 0",
             CTI_Ran = "BlockRandom:CTI_num = 0",
             CTI_Cen4 = "BlockCentral4:CTI_num = 0",
             CTI_RvC = "BlockRandom:CTI_num = BlockCentral4:CTI_num",
             CTI_PvA = "BlockPro:CTI_num = BlockAnti:CTI_num",
             CTI_P_No = "BlockPro:CTI_num = BlockNoSaccade:CTI_num",
             CTI_A_No = "BlockAnti:CTI_num = BlockNoSaccade:CTI_num",
             CTI_Bi = "(BlockPro:CTI_num + BlockAnti:CTI_num)/2 = (BlockRandom:CTI_num + BlockCentral4:CTI_num)/2")

hyp_results <- hypothesis(fit_binomial,hyp_fit)
```

Figure \@ref(fig:PredEffects) shows the posterior predictive estimates from the Bayesian GLM for the different experimental blocks and the linear effect of CTI on the proportion correct scale. Comparisons of the posterior estimates indicated that at the shortest CTI (50ms) performance in all blocks differed from one another $BF_{10}$ = `r printnum(min(abs(1/hyp_results$hypothesis$Evid.Ratio[1:10])), format = "g")`.

For all three blocks there was strong evidence in favor of a positive effect of the CTI on performance, $BF_{10}$ = `r printnum(min(abs(1/hyp_results$hypothesis$Evid.Ratio[11:15])), format = "g")`. There was strong evidence for the effect of CTI being equal for the Pro and Anti Saccade block, $BF_{01}$ = `r printnum(hyp_results$hypothesis$Evid.Ratio[17], format = "g")`, and for the Random and Central Saccade Block, $BF_{01}$ = `r printnum(hyp_results$hypothesis$Evid.Ratio[16], format = "g")`.

```{r echo=FALSE}
randFX <- ranef(fit_binomial)$ID

df_randFX <- data.frame(
  Int_No = randFX[,"Estimate","BlockNoSaccade"],
  Int_Pro = randFX[,"Estimate","BlockPro"],
  Int_Anti = randFX[,"Estimate","BlockAnti"],
  Int_Random = randFX[,"Estimate","BlockRandom"],
  Int_Central = randFX[,"Estimate","BlockCentral4"],
  CTI_No = randFX[,"Estimate","BlockNoSaccade:CTI_num"],
  CTI_Pro = randFX[,"Estimate","BlockPro:CTI_num"],
  CTI_Anti = randFX[,"Estimate","BlockAnti:CTI_num"],
  CTI_Random = randFX[,"Estimate","BlockRandom:CTI_num"],
  CTI_Central = randFX[,"Estimate","BlockCentral4:CTI_num"]
)
```


```{r echo=TRUE}
CFA_int <- readLines(here("SEM","Exp5_CFA_Int.sem"))
fit_cfa_int <- sem(CFA_int, data = df_randFX)
fitMeasures(fit_cfa_int, fit.measures = c("chisq","df","pvalue","cfi","rmsea","srmr"))
summary(fit_cfa_int, standardized = T) 
```

```{r echo=TRUE}
CFA_cti <- readLines(here("SEM","Exp5_CFA_CTI.sem"))
fit_cfa_cti <- sem(CFA_cti, data = df_randFX)
fitMeasures(fit_cfa_cti, fit.measures = c("chisq","df","pvalue","cfi","rmsea","srmr"))
summary(fit_cfa_cti, standardized = T)
lavResiduals(fit_cfa_cti)
modindices(fit_cfa_cti, sort = T) 
```

```{r echo=TRUE}
CFA_all <- readLines(here("SEM","Exp5_CFA.sem"))
fit_cfa_all <- sem(CFA_all, data = df_randFX)
fitMeasures(fit_cfa_all, fit.measures = c("chisq","df","pvalue","cfi","rmsea","srmr"))
summary(fit_cfa_all, standardized = T)
lavResiduals(fit_cfa_all)
modindices(fit_cfa_all, sort = T) 
```
